<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Frame-by-Frame Animator</title>
<style>
:root{--bg:#0b0f17;--panel:#121a27;--panel2:#0f1522;--text:#e6eefc;--muted:#9fb0cf;--accent:#5aa2ff;--danger:#ff5a7a;--border:#26344f}
*{box-sizing:border-box}
body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--text);background:linear-gradient(180deg,#081019,#070b12 55%,#05070c)}
header{padding:14px 18px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;gap:12px}
header h1{font-size:14px;margin:0;letter-spacing:.3px;color:var(--text);font-weight:600}
header .hint{font-size:12px;color:var(--muted)}
.wrap{display:grid;grid-template-columns:1fr 320px;gap:14px;padding:14px;max-width:1200px;margin:0 auto}
.card{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--border);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
.stage{padding:12px;display:flex;flex-direction:column;gap:12px}
.canvasPanel{display:flex;flex-direction:column;gap:10px}
.mainCanvasWrap{background:#060a12;border:1px solid var(--border);border-radius:12px;padding:10px;display:flex;justify-content:center;align-items:center}
canvas#main{width:512px;height:512px;border-radius:10px;border:1px solid rgba(255,255,255,.06);background:#fff;image-rendering:pixelated;touch-action:none;cursor:crosshair}

.toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
.group{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

button{appearance:none;border:1px solid var(--border);background:rgba(255,255,255,.03);color:var(--text);padding:8px 10px;border-radius:10px;font-size:12px;font-weight:600;letter-spacing:.2px;cursor:pointer;user-select:none}
button:hover{border-color:#35507c}
button.primary{border-color:rgba(90,162,255,.6);background:rgba(90,162,255,.12)}
button.danger{border-color:rgba(255,90,122,.65);background:rgba(255,90,122,.10)}
button:disabled{opacity:.55;cursor:not-allowed}

.pill{font-size:12px;color:var(--muted);padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:rgba(255,255,255,.02);display:inline-flex;gap:8px;align-items:center}
label{font-size:12px;color:var(--muted);display:flex;gap:8px;align-items:center}
input[type="range"]{width:160px}

.panelBlock{
  border:1px solid var(--border);
  border-radius:12px;
  background:rgba(0,0,0,.18);
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.panelHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.panelTitle{
  font-size:11px;
  color:var(--muted);
  letter-spacing:.35px;
  text-transform:uppercase;
}

.sidebar{padding:12px;display:flex;flex-direction:column;height:calc(100vh - 180px);overflow-y:auto}
.sidebar h2{display:none}
.sidebar .section{padding:10px;border:1px solid var(--border);border-radius:12px;background:rgba(0,0,0,.18);margin-bottom:12px;flex-shrink:0}
.sidebar .section:first-of-type{flex-shrink:1;display:flex;flex-direction:column;min-height:0}
.sidebar .section:first-of-type::before{content:'Frames';display:block;font-size:11px;color:var(--muted);letter-spacing:.35px;text-transform:uppercase;margin:0 0 10px;flex-shrink:0}
.sidebar .row{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:8px 0;flex-wrap:wrap}
.sidebar small{color:var(--muted)}
.frames{display:grid;grid-template-columns:repeat(6,1fr);gap:10px}
.framesWrap{flex:1;overflow:auto;padding-right:4px;min-height:0}
.thumb{border:1px solid var(--border);background:#060a12;border-radius:12px;padding:6px;cursor:pointer;position:relative}
.thumb.active{outline:2px solid rgba(90,162,255,.8);border-color:rgba(90,162,255,.65)}
.thumb.dragging{opacity:0.45}
.thumb.drag-over{outline:2px dashed rgba(90,162,255,.8);border-color:rgba(90,162,255,.65)}
.thumb canvas{width:100%;aspect-ratio:1/1;border-radius:8px;background:#fff;image-rendering:pixelated;border:1px solid rgba(255,255,255,.06)}
.thumb .idx{position:absolute;top:6px;left:8px;font-size:11px;padding:2px 6px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);color:#fff}

.frameOpsRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-top:10px}
.frameOpsRow .group{gap:8px}

/* Controls placed inside the Frames block: play, frame indicator, and scrubber */
.frameControls{display:flex;align-items:center;gap:10px;justify-content:space-between;margin-bottom:8px}
.frameControls .group{gap:8px}
.frameControls .scrubber{width:100%;height:28px}

.footerHint{color:var(--muted);font-size:12px;padding:6px 2px 0}

/* Toast notifications */
.toasts{position:fixed;right:18px;bottom:18px;display:flex;flex-direction:column;gap:8px;z-index:9999;padding:0;pointer-events:none}
.toast{pointer-events:auto;min-width:180px;max-width:360px;padding:10px 12px;border-radius:10px;background:linear-gradient(180deg,#0f1720,#0b131e);border:1px solid rgba(255,255,255,.06);color:var(--text);box-shadow:0 10px 30px rgba(0,0,0,.35);opacity:0;transform:translateY(6px);transition:opacity .18s ease,transform .18s ease}
.toast.visible{opacity:1;transform:translateY(0)}

@media (max-width:980px){
  .wrap{grid-template-columns:1fr}
  canvas#main{width:min(92vw,512px);height:min(92vw,512px)}
  .frames{grid-template-columns:repeat(4,1fr)}
}

/* Montage sidebar styles */
#montageSidebar .section{padding:10px}
#montageChunks{max-height:400px;overflow-y:auto}
#montageChunks .chunk-item{display:grid;grid-template-columns:48px 1fr auto;align-items:start;padding:8px;border-radius:8px;border:1px solid var(--border);background:rgba(255,255,255,.02);cursor:pointer;gap:8px}
#montageChunks .chunk-item:hover{border-color:#35507c}
#montageChunks .chunk-item.active{outline:2px solid rgba(90,162,255,.8);border-color:rgba(90,162,255,.65);background:linear-gradient(180deg,rgba(90,162,255,.06),rgba(255,255,255,.02))}
#montageChunks .chunk-thumb{width:48px;height:48px;border-radius:4px;background:rgba(0,0,0,.2);border:1px solid var(--border);display:flex;align-items:center;justify-content:center;font-size:10px;color:var(--muted);overflow:hidden}
#montageChunks .chunk-thumb canvas{width:100%;height:100%;image-rendering:pixelated}
#montageChunks .chunk-info{display:flex;flex-direction:column;gap:4px;min-width:0}
#montageChunks .chunk-badges{display:flex;gap:4px;flex-wrap:wrap}
#montageChunks .chunk-alias{font-size:11px;font-weight:600;color:var(--text);width:100%;padding:2px 4px;background:rgba(0,0,0,.15);border:1px solid var(--border);border-radius:4px}
#montageChunks .chunk-alias::placeholder{color:var(--muted);opacity:.6}
#montageChunks .chunk-controls{display:flex;gap:4px;flex-wrap:wrap}

/* Insert zone for chunk insertion */
.chunk-insert-zone{display:flex;align-items:center;justify-content:center;padding:4px;opacity:0.5;transition:opacity 0.2s ease}
.chunk-insert-zone:hover{opacity:1}
.chunk-insert-zone button{padding:4px 8px;font-size:11px;border-radius:6px;background:rgba(90,162,255,.08);border:1px dashed rgba(90,162,255,.4);color:var(--accent);cursor:pointer;min-width:auto;width:100%}
.chunk-insert-zone button:hover{background:rgba(90,162,255,.15);border-color:rgba(90,162,255,.6)}

/* Trim bar */
#trimBarCanvas{position:relative}
.trim-handle{position:absolute;top:0;height:100%;width:10px;background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(0,0,0,.08));cursor:ew-resize;border-left:1px solid rgba(0,0,0,.18);border-right:1px solid rgba(255,255,255,.06);}
.trim-selection{position:absolute;top:0;height:100%;background:linear-gradient(90deg, rgba(90,162,255,.12), rgba(90,162,255,.06));pointer-events:none}
#trimBar .panelTitle{font-size:11px;color:var(--muted);letter-spacing:.35px;text-transform:uppercase}

/* Compact icon buttons used in montage chunk controls */
.iconBtn{padding:4px 6px;font-size:12px;border-radius:8px;min-width:30px}
.iconBtn.danger{border-color:rgba(255,90,122,.65);background:rgba(255,90,122,.06)}


</style>
</head>
<body>
<header>
  <h1 id="title">Frame-by-Frame Animator</h1>
  <div id="headerHint" class="hint">
    Space play/pause · [ / ] or ←/→ prev/next · A add frame · D duplicate · Del delete frame · Ctrl/Cmd+Z undo · Ctrl/Cmd+Y redo · S save · G GIF · L load · N new
  </div>
  <div id="editorToggle" style="display:flex;gap:8px;align-items:center">
    <button id="toggleChunk" class="primary">Chunk Editor</button>
    <button id="toggleMontage">Montage Editor</button>
  </div>
</header>

<main class="wrap">
  <section class="card stage">
    <div class="canvasPanel">

      <!-- Drawing Ops -->
      <div id="drawingPanel" class="panelBlock">
        <div class="panelHeader">
          <div class="panelTitle">Drawing</div>
        </div>
        <div class="toolbar">
          <div class="group">
            <button id="toolPencil" class="primary">Pencil</button>
            <button id="toolEraser">Eraser</button>
            <button id="toolSoft">Soft</button>
            <button id="undoBtn">Undo</button>
            <button id="redoBtn">Redo</button>
          </div>
          <div class="group">
            <label>Brush
              <input id="brushSize" type="range" min="1" max="8" value="1"/>
              <span id="brushSizeLabel" class="pill">1</span>
            </label>
          </div>
        </div>
        <div class="toolbar">
          <div class="group">
            <label>Gray
              <input id="gray" type="range" min="0" max="255" value="0"/>
              <span id="grayLabel" class="pill">0</span>
            </label>
          </div>
          <div class="group">
            <label>Onion
              <input id="onion" type="range" min="0" max="8" value="5"/>
              <span id="onionLabel" class="pill">5</span>
            </label>
          </div>
        </div>
      </div>

      <div class="mainCanvasWrap">
        <canvas id="main" width="512" height="512" role="img" aria-label="Drawing canvas (128×128 grayscale)" tabindex="0"></canvas>
      </div>

      <!-- Trim bar for montage chunk trimming (always visible; disabled until a chunk is selected) -->
      <div id="trimBar" style="margin-top:10px;">
        <div class="panelBlock">
          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px;">
            <div style="font-size:12px;font-weight:600;color:var(--text)">Trim Range:</div>
            <div style="display:flex;gap:6px;align-items:center">
              <label style="font-size:11px;color:var(--muted)">Start <input id="trimStartInput" type="number" style="width:60px"/></label>
              <label style="font-size:11px;color:var(--muted)">End <input id="trimEndInput" type="number" style="width:60px"/></label>
              <button id="trimApplyBtn" style="padding:4px 10px">Apply</button>
              <button id="trimResetBtn" style="padding:4px 10px">Reset</button>
            </div>
          </div>
          <div id="trimBarCanvas" style="position:relative;height:24px;border-radius:8px;background:linear-gradient(90deg, rgba(255,255,255,.02), rgba(255,255,255,.01));border:1px solid var(--border);overflow:hidden">
            <!-- handles will be added dynamically -->
          </div>
        </div>
      </div>

      <!-- Unified Scrubber (used in both chunk and montage modes) -->
      <div class="frameControls" style="margin-top:6px;">
        <button id="playBtn" class="primary">Play</button>
        <button id="montagePlayBtn" class="primary">Play</button>
        <div style="flex:1;position:relative;">
          <!-- Montage info above scrubber (only shown in montage mode) -->
          <div id="montageInfo" style="display:none;font-size:11px;color:var(--muted);margin-bottom:4px">
            <div style="display:flex;align-items:center;justify-content:space-between">
              <span>Frames: <strong id="montageTotalFrames" style="color:var(--text)">0</strong></span>
              <span>Position: <strong id="montagePlayPos" style="color:var(--text)">0 / 0f</strong></span>
              <span>Time: <strong id="montageTimePos" style="color:var(--text)">0.0s</strong></span>
            </div>
          </div>
          
          <!-- Top ruler (frame index) - only shown in montage mode -->
          <div id="scrubberTopRuler" style="display:none;height:16px;font-size:10px;color:var(--muted);position:relative;margin-bottom:2px"></div>
          
          <!-- Scrubber with chunk delimiters -->
          <div style="position:relative;">
            <input id="montageScrubber" class="scrubber" type="range" min="1" max="1" value="1" />
            <!-- Chunk delimiter markers - only shown in montage mode -->
            <div id="chunkDelimiters" style="display:none;position:absolute;top:0;left:0;right:0;height:100%;pointer-events:none"></div>
          </div>
          
          <!-- Bottom ruler (time) - only shown in montage mode -->
          <div id="scrubberBottomRuler" style="display:none;height:16px;font-size:10px;color:var(--muted);position:relative;margin-top:2px"></div>
        </div>
      </div>



    </div>
  </section>

  <aside class="card sidebar">
    <h2>Frames</h2>

    <!-- Frames + Frame Ops -->
    <div class="section">

      <div class="frameControls">
        <span class="pill">Frame <span id="frameLabel">1</span> / <span id="frameTotal">12</span></span>
      </div>

      <div class="framesWrap">
        <div class="frames" id="frameGrid"></div>
      </div>

      <div class="frameOpsRow">
        <div class="group">
          <button id="addFrameBtn">Add</button>
          <button id="dupFrameBtn">Duplicate</button>
          <button id="delFrameBtn" class="danger">Delete</button>
        </div>
        <div class="group">
          <span class="pill">Selected: <span id="selectedFramePill">1</span></span>
        </div>
      </div>

      <div style="margin-top:10px;color:var(--muted);font-size:12px">Click thumbnail to edit — drag to reorder frames.</div>
    </div>

    <!-- Meta -->
    <div class="section">
      <div class="row"><small>Project</small><span id="lengthPill" class="pill">1.00 sec</span></div>
      <div class="row"><small>FPS</small><span class="pill">12</span></div>
      <div class="row"><small>Frames</small><span id="framesPill" class="pill">12</span></div>
      <div class="row"><small>Canvas</small><span class="pill">128×128</span></div>

      <div style="color:var(--muted);font-size:12px;margin-top:6px">Length updates automatically as you add/delete frames.</div>
    </div>

    <!-- Project Actions -->
    <div class="section">
      <div class="panelHeader">
        <div class="panelTitle">Project Actions</div>
      </div>
      <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
        <button id="saveProjectBtn">Save Project</button>
        <button id="loadProjectBtn">Load Project</button>
        <button id="saveBtn">Save GIF</button>
        <button id="newBtn" class="danger">New</button>
      </div>
      <div class="footerHint" style="margin-top:8px">Save Project is lossless JSON. Save GIF exports 512×512 with a white background.</div>
    </div>
    
    <!-- Montage Integration -->
    <div class="section">
      <div class="panelHeader">
        <div class="panelTitle">Montage Integration</div>
      </div>
      <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
        <button id="insertToMontageBtn" style="display:none">Insert to Montage</button>
        <button id="returnToMontageBtn" style="display:none">Return to Montage</button>
      </div>
    </div>
  </aside>

  <!-- Montage Sidebar (hidden by default) -->
  <aside id="montageSidebar" class="card sidebar" style="display:none">
    <h2>Montage</h2>

    <div class="section" style="padding-top:8px;flex:1;display:flex;flex-direction:column;min-height:0">
      <div class="panelHeader">
        <div class="panelTitle">Chunks</div>
        <button id="montageImportBtn" style="margin-left:auto;padding:4px 10px;font-size:11px">+ Import</button>
      </div>
      <div id="montageChunks" style="display:flex;flex-direction:column;gap:8px;margin-top:8px;overflow-y:auto;flex:1"></div>
    </div>

    <!-- Load/Save at bottom -->
    <div class="section" style="margin-top:auto">
      <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px;">
        <button id="montageLoadBtn">Load</button>
        <button id="saveMontageBtn">Save</button>
      </div>
      <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
        <div style="font-size:11px;color:var(--muted);letter-spacing:.35px;text-transform:uppercase;width:100%;margin-bottom:4px">Export</div>
        <button id="exportMontageGifBtn">GIF</button>
        <button id="exportMontageMp4Btn">MP4</button>
      </div>
    </div>
  </aside>
</main>

<input id="loadProjectInput" type="file" accept=".json" style="display:none"/>

<input id="montageImportInput" type="file" accept=".json" multiple style="display:none"/>

<input id="montageLoadInput" type="file" accept=".json" style="display:none"/>

<!-- Toast container for non-blocking notifications -->
<div id="toastContainer" aria-live="polite" aria-atomic="true" class="toasts"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
<script>
// validateProject - inline validation function
function validateProject(project, opts = {}){
  const errors = [];
  if(!project || typeof project !== 'object'){
    errors.push('Invalid project object');
    return { ok: false, errors };
  }

  if(!Array.isArray(project.frames)){
    errors.push('missing frames array');
    return { ok: false, errors };
  }

  const width = Number(project.width);
  const height = Number(project.height);
  if(!Number.isFinite(width) || !Number.isFinite(height)){
    errors.push('invalid width/height');
  }

  if(typeof opts.width !== 'undefined' && Number(opts.width) !== width){
    errors.push(`width mismatch (${width} != ${opts.width})`);
  }
  if(typeof opts.height !== 'undefined' && Number(opts.height) !== height){
    errors.push(`height mismatch (${height} != ${opts.height})`);
  }
  if(typeof opts.fps !== 'undefined' && typeof project.fps !== 'undefined' && Number(project.fps) !== Number(opts.fps)){
    errors.push(`fps mismatch (${project.fps} != ${opts.fps})`);
  }

  const frameCount = Number(project.frameCount || project.frames.length || 0);
  if(frameCount !== project.frames.length){
    errors.push(`frameCount (${frameCount}) does not match frames.length (${project.frames.length})`);
  }

  const expectedLen = (Number.isFinite(width) && Number.isFinite(height)) ? (width * height) : null;
  if(expectedLen !== null){
    for(let i = 0; i < project.frames.length; i++){
      const b64 = project.frames[i];
      if(typeof b64 !== 'string'){
        errors.push(`frame ${i} not a string`);
        break;
      }
      try{
        const bin = atob(b64);
        if(bin.length !== expectedLen){ errors.push(`frame ${i} length ${bin.length} != ${expectedLen}`); break; }
      }catch(e){
        errors.push(`frame ${i} invalid base64`);
        break;
      }
    }
  }

  return { ok: errors.length === 0, errors };
}

(()=>{

// Fixed raster + fixed FPS
// CONFIG: change these to adjust internal raster, exported display size, and playback rate:
//  - W, H: internal frame resolution (frames stored as W*H bytes).
//  - DISPLAY: visible canvas / GIF export resolution (can be larger than W to upscale).
//  - FPS: playback and GIF framerate (used for playback interval and GIF frame delay).
const W = 128, H = 128;
const DISPLAY = 512;
const FPS = 12;

const MAX_FRAMES = 600;
const UNDO_LIMIT = 100;

// Frames + history (dynamic length)
// NOTE: `frames` holds Uint8Array instances (W*H bytes each) representing grayscale pixels
// (0 = black, 255 = white). `undoStacks` / `redoStacks` are per-frame arrays of stroke deltas.
let frames = [];
let undoStacks = [];
let redoStacks = [];

// State
let current = 0;
let isPlaying = false;
let tool = 'pencil';
let brush = 1;
let gray = 0;
let onionDepth = 5;
let drawing = false;
let lastPt = null;

// Active stroke diff recording
let activeStrokeMap = null;

// DOM
const main = document.getElementById('main');
const ctx = main.getContext('2d', { alpha:false, willReadFrequently:true });
ctx.imageSmoothingEnabled = false;

const frameLabel = document.getElementById('frameLabel');
const frameTotalEl = document.getElementById('frameTotal');
const selectedFramePill = document.getElementById('selectedFramePill');

const playBtn = document.getElementById('playBtn');
const saveProjectBtn = document.getElementById('saveProjectBtn');
const loadProjectBtn = document.getElementById('loadProjectBtn');
const loadProjectInput = document.getElementById('loadProjectInput');

const saveBtn = document.getElementById('saveBtn');
const newBtn = document.getElementById('newBtn');

const addFrameBtn = document.getElementById('addFrameBtn');
const dupFrameBtn = document.getElementById('dupFrameBtn');
const delFrameBtn = document.getElementById('delFrameBtn');

const toolPencil = document.getElementById('toolPencil');
const toolEraser = document.getElementById('toolEraser');
const toolSoft = document.getElementById('toolSoft');

const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');

const brushSize = document.getElementById('brushSize');
const brushSizeLabel = document.getElementById('brushSizeLabel');

const graySlider = document.getElementById('gray');
const grayLabel = document.getElementById('grayLabel');

const onionSlider = document.getElementById('onion');
const onionLabel = document.getElementById('onionLabel');

const frameGrid = document.getElementById('frameGrid');
const lengthPill = document.getElementById('lengthPill');
const framesPill = document.getElementById('framesPill');
const montageScrubber = document.getElementById('montageScrubber');

// Offscreen for 128x128 composition
const off = document.createElement('canvas');
off.width = W; off.height = H;
const offCtx = off.getContext('2d', { willReadFrequently:true });
offCtx.imageSmoothingEnabled = false;

// Thumbnails
const thumbs = [];
const thumbCanvases = [];

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function roundTo(n, decimals=2){
  const p = Math.pow(10, decimals);
  return Math.round(n*p)/p;
}

function makeBlankFrame(){
  // Creates a blank grayscale frame as a byte array (1 byte per pixel).
  // To switch to color or RGBA frames, replace this with a Uint8ClampedArray(W*H*4)
  // and update compose/draw functions accordingly.
  const a = new Uint8Array(W*H);
  a.fill(255);
  return a;
}

function ensureStacks(count){
  while(undoStacks.length < count) undoStacks.push([]);
  while(redoStacks.length < count) redoStacks.push([]);
  if(undoStacks.length > count) undoStacks.length = count;
  if(redoStacks.length > count) redoStacks.length = count;
}

function updateProjectMetaUI(){
  const count = frames.length;
  frameTotalEl.textContent = String(count);
  framesPill.textContent = String(count);
  lengthPill.textContent = `${roundTo(count / FPS, 2)} sec`;
  selectedFramePill.textContent = String(current + 1);

  // scrubber sync (if present) — use `montageScrubber` as the single control
  if(montageScrubber){
    montageScrubber.step = '1';
    if(currentMode === 'montage'){
      const totalMontage = Math.max(1, computeMontageTotalFrames());
      montageScrubber.max = String(totalMontage);
      let before = 0; for(let i=0;i<Math.min(_montagePos.chunkIdx, montageChunks.length);i++){ const c = montageChunks[i]; before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0; }
      const pos = Math.max(1, (before + (_montagePos.frameIdx || 0) + 1));
      montageScrubber.value = String(Math.min(pos, totalMontage));
      montageScrubber.style.display = '';
    }else{
      montageScrubber.max = String(count);
      montageScrubber.value = String(current + 1);
      montageScrubber.style.display = '';
    }
  }
}

function updateUI(){
  frameLabel.textContent = String(current + 1);
  selectedFramePill.textContent = String(current + 1);
  updateProjectMetaUI();
  updateUndoRedoButtons();
}

function setTool(next){
  tool = next;
  toolPencil.classList.toggle('primary', tool === 'pencil');
  toolEraser.classList.toggle('primary', tool === 'eraser');
  toolSoft.classList.toggle('primary', tool === 'soft');
  // Reflect state for assistive technologies
  try{
    toolPencil.setAttribute('aria-pressed', String(tool === 'pencil'));
    toolEraser.setAttribute('aria-pressed', String(tool === 'eraser'));
    toolSoft.setAttribute('aria-pressed', String(tool === 'soft'));
  }catch(_){ }
}

function setCurrent(idx){
  current = clamp(idx, 0, frames.length - 1);
  thumbs.forEach((el,i)=>el.classList.toggle('active', i === current));
  updateUI();
  renderMain();
}

function xyToIndex(x,y){ return y*W + x; }

function getPointerXY(ev){
  const rect = main.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (W / rect.width);
  const y = (ev.clientY - rect.top) * (H / rect.height);
  return {
    x: clamp(Math.floor(x), 0, W - 1),
    y: clamp(Math.floor(y), 0, H - 1)
  };
}

// Fixed brush: size s draws s×s square (even sizes included)
// Brush implementation is intentionally simple (square). To make a round brush:
// - replace this with a circular mask (distance check from center)
// - or implement alpha blending for softer strokes.
function drawDot(frameArr, x, y, value, size){
  const s = Math.max(1, size|0);
  const start = -Math.floor(s/2);
  const end = start + s - 1;
  for(let dy = start; dy <= end; dy++){
    for(let dx = start; dx <= end; dx++){
      const xx = x + dx, yy = y + dy;
      if(xx < 0 || yy < 0 || xx >= W || yy >= H) continue;
      const idx = xyToIndex(xx, yy);

      if(activeStrokeMap && !activeStrokeMap.has(idx)){
        activeStrokeMap.set(idx, frameArr[idx]);
      }
      frameArr[idx] = value;
    }
  }
}

function drawLine(frameArr, x0, y0, x1, y1, value, size){
  let dx = Math.abs(x1-x0);
  let sx = x0 < x1 ? 1 : -1;
  let dy = -Math.abs(y1-y0);
  let sy = y0 < y1 ? 1 : -1;
  let err = dx + dy;
  while(true){
    drawDot(frameArr, x0, y0, value, size);
    if(x0 === x1 && y0 === y1) break;
    const e2 = 2 * err;
    if(e2 >= dy){ err += dy; x0 += sx; }
    if(e2 <= dx){ err += dx; y0 += sy; }
  }
}

// Soft (blended) brush: blends the target value into existing pixels with a radial falloff
// to produce smoother, less pixelated edges. Deltas are recorded in `activeStrokeMap`
// so undo/redo continues to work as expected.
function drawSoftDot(frameArr, x, y, value, size){
  const s = Math.max(1, size|0);
  const start = -Math.floor(s/2);
  const end = start + s - 1;
  const radius = Math.max(0.5, s / 2);

  for(let dy = start; dy <= end; dy++){
    for(let dx = start; dx <= end; dx++){
      const xx = x + dx, yy = y + dy;
      if(xx < 0 || yy < 0 || xx >= W || yy >= H) continue;
      const idx = xyToIndex(xx, yy);
      const dist = Math.hypot(dx, dy);
      let alpha = 1 - (dist / radius);
      if(radius === 0) alpha = 1;
      alpha = clamp(alpha, 0, 1);
      // Slight gamma to soften edges
      alpha = Math.pow(alpha, 1.2);

      const prev = frameArr[idx];
      const blended = Math.round(prev * (1 - alpha) + value * alpha);
      if(activeStrokeMap && !activeStrokeMap.has(idx)){
        activeStrokeMap.set(idx, prev);
      }
      frameArr[idx] = blended;
    }
  }
}

function drawLineSoft(frameArr, x0, y0, x1, y1, value, size){
  let dx = Math.abs(x1-x0);
  let sx = x0 < x1 ? 1 : -1;
  let dy = -Math.abs(y1-y0);
  let sy = y0 < y1 ? 1 : -1;
  let err = dx + dy;
  while(true){
    drawSoftDot(frameArr, x0, y0, value, size);
    if(x0 === x1 && y0 === y1) break;
    const e2 = 2 * err;
    if(e2 >= dy){ err += dy; x0 += sx; }
    if(e2 <= dx){ err += dx; y0 += sy; }
  }
}

// Onion skin unchanged
function ghostGrayForDistance(d){ return clamp(110 + (d-1)*30, 110, 235); }

function composeWithOnionSkin(frameIndex, depth){
  const out = new Uint8ClampedArray(W*H*4);
  const base = new Uint8Array(W*H);
  base.fill(255);

  for(let d=1; d<=depth; d++){
    const idx = frameIndex - d;
    if(idx < 0) break;
    const g = ghostGrayForDistance(d);
    const src = frames[idx];
    for(let p=0; p<src.length; p++){
      if(src[p] < 250){
        if(g < base[p]) base[p] = g;
      }
    }
  }

  const cur = frames[frameIndex];
  for(let p=0; p<cur.length; p++){
    if(cur[p] < base[p]) base[p] = cur[p];
  }

  for(let p=0,o=0; p<base.length; p++,o+=4){
    const v = base[p];
    out[o]=v; out[o+1]=v; out[o+2]=v; out[o+3]=255;
  }
  return new ImageData(out, W, H);
}

function composeFrameOnly(frameIndex){
  const out = new Uint8ClampedArray(W*H*4);
  const src = frames[frameIndex];
  for(let p=0,o=0; p<src.length; p++,o+=4){
    const v = src[p];
    out[o]=v; out[o+1]=v; out[o+2]=v; out[o+3]=255;
  }
  return new ImageData(out, W, H);
}

function renderMain(){
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const target = DISPLAY * dpr;
  if(main.width !== target || main.height !== target){
    main.width = target;
    main.height = target;
    ctx.imageSmoothingEnabled = false;
  }

  offCtx.putImageData(isPlaying ? composeFrameOnly(current) : composeWithOnionSkin(current, onionDepth), 0, 0);
  ctx.clearRect(0, 0, main.width, main.height);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(off, 0, 0, main.width, main.height);
}

function renderThumb(i){
  const c = thumbCanvases[i];
  const tctx = c.getContext('2d', { alpha:false });
  tctx.imageSmoothingEnabled = false;

  offCtx.putImageData(composeFrameOnly(i), 0, 0);
  tctx.clearRect(0, 0, c.width, c.height);
  tctx.drawImage(off, 0, 0, c.width, c.height);
}

function renderAllThumbs(){
  for(let i=0; i<frames.length; i++) renderThumb(i);
}

// Simple non-blocking toast notifications (falls back to alert)
function showToast(msg, {timeout=3000}={}){
  const container = document.getElementById('toastContainer');
  if(!container){ alert(msg); return; }
  const el = document.createElement('div');
  el.className = 'toast';
  el.textContent = msg;
  container.appendChild(el);
  // trigger visible state
  requestAnimationFrame(()=> el.classList.add('visible'));
  setTimeout(()=>{ el.classList.remove('visible'); setTimeout(()=> el.remove(), 200); }, timeout);
}

function notify(msg){ showToast(msg); }

// -------------------- Undo / Redo --------------------
// Per-frame undo/redo stacks store delta objects `{idxs, before, after}` produced by
// `commitStroke()`. This keeps memory bounded and allows frame-level undo without
// copying entire frames.

function updateUndoRedoButtons(){
  const canU = !isPlaying && undoStacks[current] && undoStacks[current].length > 0;
  const canR = !isPlaying && redoStacks[current] && redoStacks[current].length > 0;
  undoBtn.disabled = !canU;
  redoBtn.disabled = !canR;
}

function beginStroke(){ activeStrokeMap = new Map(); }

function commitStroke(){
  if(!activeStrokeMap) return;
  if(activeStrokeMap.size === 0){
    activeStrokeMap = null;
    return;
  }

  const idxs = new Uint32Array(activeStrokeMap.size);
  const before = new Uint8Array(activeStrokeMap.size);
  const after = new Uint8Array(activeStrokeMap.size);

  let k = 0;
  const frameArr = frames[current];
  for(const [idx, prev] of activeStrokeMap.entries()){
    idxs[k] = idx;
    before[k] = prev;
    after[k] = frameArr[idx];
    k++;
  }

  undoStacks[current].push({ idxs, before, after });
  if(undoStacks[current].length > UNDO_LIMIT) undoStacks[current].shift();

  redoStacks[current].length = 0;

  activeStrokeMap = null;
  updateUndoRedoButtons();
}

function applyDelta(frameIdx, idxs, values){
  const arr = frames[frameIdx];
  for(let i=0; i<idxs.length; i++){
    arr[idxs[i]] = values[i];
  }
}

function undo(){
  if(isPlaying) return;
  const stack = undoStacks[current];
  if(!stack || stack.length === 0) return;

  const delta = stack.pop();
  applyDelta(current, delta.idxs, delta.before);
  redoStacks[current].push(delta);

  renderMain();
  renderThumb(current);
  updateUndoRedoButtons();
}

function redo(){
  if(isPlaying) return;
  const stack = redoStacks[current];
  if(!stack || stack.length === 0) return;

  const delta = stack.pop();
  applyDelta(current, delta.idxs, delta.after);
  undoStacks[current].push(delta);
  if(undoStacks[current].length > UNDO_LIMIT) undoStacks[current].shift();

  renderMain();
  renderThumb(current);
  updateUndoRedoButtons();
}

// -------------------- Timeline operations (Add / Duplicate / Delete) --------------------

function insertFrame(afterIndex, sourceFrameOrNull){
  if(isPlaying) return;
  if(frames.length >= MAX_FRAMES){
    notify(`Max frames reached (${MAX_FRAMES}).`);
    return;
  }

  const insertAt = clamp(afterIndex + 1, 0, frames.length);

  const newFrame = makeBlankFrame();
  if(sourceFrameOrNull instanceof Uint8Array){
    newFrame.set(sourceFrameOrNull);
  }

  frames.splice(insertAt, 0, newFrame);
  undoStacks.splice(insertAt, 0, []);
  redoStacks.splice(insertAt, 0, []);
  ensureStacks(frames.length);

  initThumbs(true);
  renderAllThumbs();
  setCurrent(insertAt);
  updateProjectMetaUI();
}

function addBlankAfterCurrent(){ insertFrame(current, null); }
function duplicateAfterCurrent(){ insertFrame(current, frames[current]); }

function deleteCurrentFrame(){
  if(isPlaying) return;
  if(frames.length <= 1){
    notify('Cannot delete the last remaining frame.');
    return;
  }

  const n = current + 1;
  const ok = confirm(`Delete frame ${n}? This cannot be undone.`);
  if(!ok) return;

  frames.splice(current, 1);
  undoStacks.splice(current, 1);
  redoStacks.splice(current, 1);
  ensureStacks(frames.length);

  // keep selection sensible
  current = clamp(current, 0, frames.length - 1);

  initThumbs(true);
  renderAllThumbs();
  renderMain();
  updateUI();
}

// Insert a frame from index `from` so it appears immediately BEFORE the frame at index `to` (drop target).
// `to` should be the index of the thumbnail dropped onto, or `frames.length` to append at the end.
// This updates frames and undo/redo stacks and keeps selection sensible.
function insertFrameBefore(from, to){
  if(isPlaying) return;
  // No-op for invalid indices or dropping onto itself
  if(from === to || from < 0 || to < 0) return;

  // Compute an insertion index in the array *after* we remove the source frame.
  // When moving forward (from < to), the target shifts left by 1 after removal,
  // so we want to insert at (to - 1). Otherwise insert at `to`.
  let insertAt = (from < to) ? (to - 1) : to;

  // Remove source frame and its history first
  const f = frames.splice(from, 1)[0];
  const u = undoStacks.splice(from, 1)[0];
  const r = redoStacks.splice(from, 1)[0];

  // After removal, clamp insertion position to valid bounds [0, frames.length]
  insertAt = clamp(insertAt, 0, frames.length);

  // Insert at computed position
  frames.splice(insertAt, 0, f);
  undoStacks.splice(insertAt, 0, u);
  redoStacks.splice(insertAt, 0, r);

  // Adjust current index to keep selection consistent
  if(current === from){
    current = insertAt;
  }else if(from < insertAt){
    if(current > from && current <= insertAt) current -= 1;
  }else{
    if(current >= insertAt && current < from) current += 1;
  }

  initThumbs(true);
  renderAllThumbs();
  renderMain();
  updateUI();
}

// -------------------- Project Save/Load (FPS fixed at 12) --------------------
// Projects store raw frame bytes base64-encoded. This keeps export/import tiny and
// fully lossless for the internal byte representation. To switch to PNG data URIs,
// change `saveProject()` to encode `off.toDataURL()` per-frame and update `loadProject()` accordingly.

// Helper to prompt for filename
let lastProjectPath = '';
let lastMontagePath = '';

function promptForFilename(defaultName, type = 'project'){
  const path = type === 'montage' ? lastMontagePath : lastProjectPath;
  const promptMsg = path ? `Filename (last: ${path}):` : 'Filename:';
  const userInput = prompt(promptMsg, defaultName);
  if(userInput === null) return null; // User cancelled
  const filename = userInput.trim() || defaultName;
  // Store the path
  if(type === 'montage') lastMontagePath = filename;
  else lastProjectPath = filename;
  return filename;
}

function saveProject(){
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  const defaultName = lastProjectPath || `chunk-${ts}.json`;
  const filename = promptForFilename(defaultName, 'project');
  if(!filename) return; // User cancelled
  
  const project = {
    version: '1.3',
    width: W,
    height: H,
    fps: FPS,
    frameCount: frames.length,
    timestamp: new Date().toISOString(),
    frames: frames.map(f=>{
      let binary = '';
      for(let i=0;i<f.length;i++) binary += String.fromCharCode(f[i]);
      return btoa(binary);
    })
  };

  const json = JSON.stringify(project, null, 2);
  const blob = new Blob([json], { type:'application/json' });

  const a = document.createElement('a');
  a.download = filename.endsWith('.json') ? filename : `${filename}.json`;
  a.href = URL.createObjectURL(blob);

  document.body.appendChild(a);
  a.click();
  a.remove();

  setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
  notify(`Project saved as ${a.download}`);
}

async function loadProject(file){
  const text = await file.text();
  let project;
  try{
    project = JSON.parse(text);
  }catch(e){
    notify(`Failed to parse project JSON: ${e.message}`);
    console.error('Failed to parse project', file.name, e);
    throw e;
  }

  if(!project || !project.frames || !Array.isArray(project.frames)){
    const msg = 'Invalid project file format: missing frames array';
    notify(msg);
    throw new Error(msg);
  }
  if(project.width !== W || project.height !== H){
    const msg = `Project dimensions (${project.width}×${project.height}) don't match canvas (${W}×${H})`;
    notify(msg);
    throw new Error(msg);
  }

  const nextCount = clamp(Number(project.frameCount || project.frames.length || 1), 1, MAX_FRAMES);

  // validate using shared validateProject helper so we keep logic consistent with scripts/validator
  try{
    if(typeof validateProject !== 'function') throw new Error('Validation function not available');
    const res = validateProject(project, { width: W, height: H, fps: FPS });
    if(!res.ok) throw new Error(res.errors.join('; '));
  }catch(e){
    notify(`Project validation failed: ${e.message}`);
    console.error('Project validation failed', file.name, e);
    throw e;
  }

  frames = Array.from({length: nextCount}, ()=>makeBlankFrame());
  undoStacks = [];
  redoStacks = [];
  ensureStacks(nextCount);

  for(let i=0; i<nextCount; i++){
    if(i < project.frames.length){
      const base64 = project.frames[i];
      const binary = atob(base64);
      const arr = new Uint8Array(binary.length);
      for(let j=0; j<binary.length; j++) arr[j] = binary.charCodeAt(j);
      frames[i].set(arr);
    }else{
      frames[i].fill(255);
    }
  }

  initThumbs(false);
  setCurrent(0);
  renderAllThumbs();
  renderMain();
  updateUI();
  
  // Store filename for future saves
  lastProjectPath = file.name;
  notify(`Loaded ${file.name}`);
}

// -------------------- GIF Export (512×512, white background) --------------------
// Export composes each frame to a DISPLAY×DISPLAY canvas (white background) and feeds
// frames to `gif.js`. `getGifWorkerBlobUrl()` prefers `./vendor/gif.worker.js` and falls
// back to CDN; keep `vendor/gif.worker.js` in-project for offline builds.
// Worker loader: try local vendor/gif.worker.js first, then fallback to CDN. Returns a blob URL.
let _gifWorkerBlobUrl = null;
async function getGifWorkerBlobUrl(){
  if(_gifWorkerBlobUrl) return _gifWorkerBlobUrl;

  // Try both the expected worker filename and a previously observed misspelling in this repository
  const candidates = ['./vendor/gif.worker.js', './vendor/gif.woker.js', 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'];
  for(const url of candidates){
    try{
      const resp = await fetch(url);
      if(!resp.ok) continue;
      const text = await resp.text();
      const blob = new Blob([text], { type: 'application/javascript' });
      _gifWorkerBlobUrl = URL.createObjectURL(blob);
      console.info('Loaded gif.worker from', url);
      return _gifWorkerBlobUrl;
    }catch(err){
      console.warn('Failed to fetch worker from', url, err);
      continue;
    }
  }

  notify('Could not load gif.worker.js. Add ./vendor/gif.worker.js to your project or enable network access.');
  throw new Error('gif.worker.js not available');
}

function setExporting(state){
  const disable = Boolean(state);

  // Project buttons
  saveProjectBtn.disabled = disable;
  loadProjectBtn.disabled = disable;
  saveBtn.disabled = disable;
  newBtn.disabled = disable;

  // Frame buttons
  addFrameBtn.disabled = disable;
  dupFrameBtn.disabled = disable;
  delFrameBtn.disabled = disable;

  // Drawing controls
  toolPencil.disabled = disable;
  toolEraser.disabled = disable;
  brushSize.disabled = disable;
  graySlider.disabled = disable;
  onionSlider.disabled = disable;

  // Undo/redo
  undoBtn.disabled = disable;
  redoBtn.disabled = disable;

  // Playback
  playBtn.disabled = disable;

  // Scrubber (in Frames block)
  if(montageScrubber) montageScrubber.disabled = disable;

  // Provide simple feedback
  saveBtn.textContent = disable ? 'Exporting...' : 'Save GIF';
}

async function saveGif(){
  setExporting(true);
  try{
    const workerUrl = await getGifWorkerBlobUrl();

    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: DISPLAY,
      height: DISPLAY,
      repeat: 0,
      workerScript: workerUrl
    });

    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = DISPLAY;
    exportCanvas.height = DISPLAY;
    const ectx = exportCanvas.getContext('2d', { alpha:false });
    ectx.imageSmoothingEnabled = false;

    const delay = Math.round(1000 / FPS);

    for(let i=0; i<frames.length; i++){
      offCtx.putImageData(composeFrameOnly(i), 0, 0);

      ectx.setTransform(1,0,0,1,0,0);
      ectx.clearRect(0,0,DISPLAY,DISPLAY);
      ectx.fillStyle = '#ffffff';
      ectx.fillRect(0,0,DISPLAY,DISPLAY);

      ectx.imageSmoothingEnabled = false;
      ectx.drawImage(off, 0, 0, DISPLAY, DISPLAY);

      gif.addFrame(exportCanvas, { copy:true, delay });
    }

    await new Promise((resolve, reject)=>{
      gif.on('finished', blob => {
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g,'-');
        a.download = `animation-${ts}.gif`;
        a.href = URL.createObjectURL(blob);
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1500);

        // revoke worker blob URL if we generated it
        if(workerUrl && workerUrl.startsWith('blob:')){
          try{ URL.revokeObjectURL(workerUrl); }catch(_){ }
          if(workerUrl === _gifWorkerBlobUrl) _gifWorkerBlobUrl = null;
        }

        setExporting(false);
        resolve();
      });

      gif.on('error', err => {
        console.error('GIF render error', err);
        notify(`Failed to render GIF: ${err && err.message ? err.message : String(err)}`);
        // revoke worker url on error
        if(workerUrl && workerUrl.startsWith('blob:')){
          try{ URL.revokeObjectURL(workerUrl); }catch(_){ }
          if(workerUrl === _gifWorkerBlobUrl) _gifWorkerBlobUrl = null;
        }
        setExporting(false);
        reject(err);
      });

      gif.render();
    });





  }catch(err){
    console.error('saveGif error', err);
    notify(`Failed to start GIF export: ${err && err.message ? err.message : String(err)}`);
    setExporting(false);
  }finally{
    setExporting(false);
  }
}



// -------------------- Playback --------------------

let playTimer = null;

function setPlaying(next){
  isPlaying = next;
  playBtn.textContent = isPlaying ? 'Pause' : 'Play';

  const disable = isPlaying;

  // Project buttons
  saveProjectBtn.disabled = disable;
  loadProjectBtn.disabled = disable;
  saveBtn.disabled = disable;
  newBtn.disabled = disable;

  // Frame buttons (now in sidebar)
  addFrameBtn.disabled = disable;
  dupFrameBtn.disabled = disable;
  delFrameBtn.disabled = disable;

  // Drawing controls
  toolPencil.disabled = disable;
  toolEraser.disabled = disable;
  brushSize.disabled = disable;
  graySlider.disabled = disable;
  onionSlider.disabled = disable;

  // Undo/redo
  if(disable){
    undoBtn.disabled = true;
    redoBtn.disabled = true;
  }else{
    updateUndoRedoButtons();
  }

  if(isPlaying){
    let idx = current;
    const interval = Math.round(1000 / FPS);
    playTimer = setInterval(()=>{
      current = idx;
      thumbs.forEach((el,i)=>el.classList.toggle('active', i === current));
      updateUI();
      renderMain();
      idx = (idx + 1) % frames.length;
    }, interval);
  }else{
    if(playTimer){
      clearInterval(playTimer);
      playTimer = null;
    }
    renderMain();
    updateUI();
  }
}

// -------------------- Thumbnails --------------------
// `initThumbs(preserveIndex)` builds the thumbnail grid. If `preserveIndex=false` the
// selection is reset to the first frame (useful after load/new).

function initThumbs(preserveIndex = true){
  const prev = current;

  frameGrid.innerHTML = '';
  thumbs.length = 0;
  thumbCanvases.length = 0;

  for(let i=0; i<frames.length; i++){
    const el = document.createElement('div');
    el.className = 'thumb';
    el.title = `Frame ${i+1}`;

    const idx = document.createElement('div');
    idx.className = 'idx';
    idx.textContent = String(i+1);

    const c = document.createElement('canvas');
    c.width = 64;
    c.height = 64;
    c.getContext('2d', { alpha:false }).imageSmoothingEnabled = false;

    el.appendChild(idx);
    el.appendChild(c);

    // Click selects frame
    el.addEventListener('click', ()=>{
      if(isPlaying) return;
      setCurrent(i);
    });

    // Make thumbnails draggable to support reordering
    el.draggable = true;

    el.addEventListener('dragstart', ev => {
      if(isPlaying){ ev.preventDefault(); return; }
      try{ ev.dataTransfer.setData('text/plain', String(i)); }catch(_){ }
      ev.dataTransfer.effectAllowed = 'move';
      el.classList.add('dragging');
    });

    el.addEventListener('dragover', ev => {
      ev.preventDefault();
      ev.dataTransfer.dropEffect = 'move';
      el.classList.add('drag-over');
    });

    el.addEventListener('dragleave', ev => {
      el.classList.remove('drag-over');
    });

    el.addEventListener('drop', ev => {
      ev.preventDefault();
      el.classList.remove('drag-over');
      const from = Number(ev.dataTransfer.getData('text/plain'));
      const to = thumbs.indexOf(el);
      if(Number.isNaN(from) || from === to) return;
      insertFrameBefore(from, to);
    });

    el.addEventListener('dragend', ev => {
      thumbs.forEach(t=>t.classList.remove('dragging','drag-over'));
    });

    frameGrid.appendChild(el);
    thumbs.push(el);
    thumbCanvases.push(c);
  }

  const next = preserveIndex ? clamp(prev, 0, frames.length - 1) : 0;
  setCurrent(next);
  renderAllThumbs();
  updateProjectMetaUI();
}

// Allow dropping on the grid background to move a frame to the end
frameGrid.addEventListener('dragover', ev => { ev.preventDefault(); ev.dataTransfer.dropEffect = 'move'; });
frameGrid.addEventListener('drop', ev => { ev.preventDefault(); const from = Number(ev.dataTransfer.getData('text/plain')); if(Number.isNaN(from)) return; insertFrameBefore(from, frames.length); });

// -------------------- Drawing --------------------
// Pointer events (pointerdown/pointermove/pointerup) call `applyStroke()` which
// records deltas via `beginStroke()` / `commitStroke()`. To add a new tool,
// handle it in `applyStroke()` and set state via `setTool()`.

function applyStroke(from, to){
  const frameArr = frames[current];
  const value = (tool === 'eraser') ? 255 : gray;

  if(tool === 'soft'){
    if(!from){
      drawSoftDot(frameArr, to.x, to.y, value, brush);
    }else{
      drawLineSoft(frameArr, from.x, from.y, to.x, to.y, value, brush);
    }
  }else{
    if(!from){
      drawDot(frameArr, to.x, to.y, value, brush);
    }else{
      drawLine(frameArr, from.x, from.y, to.x, to.y, value, brush);
    }
  }

  renderMain();
  renderThumb(current);
}

main.addEventListener('pointerdown', ev=>{
  if(isPlaying) return;
  if(currentMode !== 'chunk') return; // disable drawing in montage mode
  drawing = true;
  main.setPointerCapture(ev.pointerId);

  beginStroke();
  const pt = getPointerXY(ev);
  lastPt = pt;
  applyStroke(null, pt);
});

main.addEventListener('pointermove', ev=>{
  if(!drawing || isPlaying) return;
  if(currentMode !== 'chunk') return; // disable drawing in montage mode
  const pt = getPointerXY(ev);
  applyStroke(lastPt, pt);
  lastPt = pt;
});

function endDraw(ev){
  if(!drawing) return;
  drawing = false;
  lastPt = null;

  commitStroke();

  try{ main.releasePointerCapture(ev.pointerId); }catch(_){}
}

main.addEventListener('pointerup', endDraw);
main.addEventListener('pointercancel', endDraw);

// -------------------- UI events --------------------

toolPencil.addEventListener('click', ()=>setTool('pencil'));
toolEraser.addEventListener('click', ()=>setTool('eraser'));
toolSoft.addEventListener('click', ()=>setTool('soft'));

undoBtn.addEventListener('click', ()=>undo());
redoBtn.addEventListener('click', ()=>redo());

addFrameBtn.addEventListener('click', ()=>addBlankAfterCurrent());
dupFrameBtn.addEventListener('click', ()=>duplicateAfterCurrent());
delFrameBtn.addEventListener('click', ()=>deleteCurrentFrame());

playBtn.addEventListener('click', ()=>setPlaying(!isPlaying));

// Scrubber: using single montageScrubber for both chunk and montage modes
if(montageScrubber){
  montageScrubber.addEventListener('pointerdown', ()=>{
    if(isPlaying) setPlaying(false);
    if(montagePlaying) stopMontagePlayback();
  });
  montageScrubber.addEventListener('input', ()=>{
    // Unified scrubber handler for both chunk editor and montage modes
    // This is the single 'input' listener for montageScrubber - handles both:
    // 1. Chunk editor mode (currentMode !== 'montage'): calls setCurrent() to select frame
    // 2. Montage mode: interprets scrubber as global montage frame index and renders accordingly
    
    // always pause active playback modes when user scrubs
    if(isPlaying) setPlaying(false);
    if(montagePlaying) stopMontagePlayback();

    // Normal frame mode: select the frame and render it
    if(currentMode !== 'montage'){
      setCurrent(Number(montageScrubber.value) - 1);
      renderMain(); // Explicitly render to ensure canvas updates
      return;
    }

    // Montage mode: interpret scrubber as global montage frame index (1-based)
    const totalMontage = computeMontageTotalFrames();
    const pos = clamp(Number(montageScrubber.value), 1, Math.max(1, totalMontage));

    let acc = 0;
    let found = false;
    for(let i=0;i<montageChunks.length;i++){
      const ch = montageChunks[i];
      const len = (ch.frameRange && (ch.frameRange.end - ch.frameRange.start)) || 0;
      if(pos <= acc + len){
        const frameIdx = pos - acc - 1;
        // update internal playhead
        _montagePos.chunkIdx = i;
        _montagePos.frameIdx = frameIdx;
        // render the frame if project available
        if(ch._project){
          const frameInSource = ch.frameRange.start + frameIdx;
          if(frameInSource < (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))){
            const bytes = _decodeFrameFromProject(ch._project, frameInSource);
            const chunkInfo = {
              name: ch.name,
              alias: ch.alias,
              frameIdx: frameInSource,
              totalFrames: (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))
            };
            renderPreviewFrameBytes(bytes, chunkInfo);
          }
        }
        // update selection highlight without forcing the chunk-start preview render
        selectMontageChunk(i, false);
        const playPosEl = document.getElementById('montagePlayPos'); if(playPosEl) playPosEl.textContent = `${pos} / ${totalMontage}f`;
        found = true;
        break;
      }
      acc += len;
    }

    if(!found){
      const blank = new Uint8Array(W*H); blank.fill(240); renderPreviewFrameBytes(blank);
      const playPosEl = document.getElementById('montagePlayPos'); if(playPosEl) playPosEl.textContent = `0 / ${totalMontage}f`;
    }
  });
}

// Dedicated montage scrubber (per-frame across all chunks)
// Note: The 'input' event listener for montageScrubber is defined earlier (line ~1337)
// and handles both chunk editor mode and montage mode. The 'pointerdown' listener
// is kept here for consistency with other scrubber controls.
if(montageScrubber){
  montageScrubber.addEventListener('pointerdown', ()=>{
    if(isPlaying) setPlaying(false);
    if(montagePlaying) stopMontagePlayback();
  });
}


saveProjectBtn.addEventListener('click', ()=>{
  if(isPlaying) return;
  saveProject();
});

loadProjectBtn.addEventListener('click', ()=>{
  if(isPlaying) return;
  loadProjectInput.value = '';
  loadProjectInput.click();
});

loadProjectInput.addEventListener('change', async ()=>{
  if(isPlaying) return;
  const file = loadProjectInput.files && loadProjectInput.files[0];
  if(!file) return;
  try{
    await loadProject(file);
  }catch(err){
    console.error(err);
    notify(`Failed to load project: ${err && err.message ? err.message : String(err)}`);
  }
});

saveBtn.addEventListener('click', ()=>{
  if(isPlaying) return;
  saveGif();
});

newBtn.addEventListener('click', ()=>{
  if(isPlaying) return;

  // reset to 12 blank frames
  frames = Array.from({length: 12}, ()=>makeBlankFrame());
  undoStacks = [];
  redoStacks = [];
  ensureStacks(frames.length);

  current = 0;
  initThumbs(false);
  renderAllThumbs();
  renderMain();
  updateUI();
  
  // Clear editing context when creating new project
  _editingChunkContext = null;
  updateMontageIntegrationButtons();
});

// Montage integration buttons
const insertToMontageBtn = document.getElementById('insertToMontageBtn');
const returnToMontageBtn = document.getElementById('returnToMontageBtn');
if(insertToMontageBtn){
  insertToMontageBtn.addEventListener('click', ()=>{
    if(isPlaying) return;
    insertChunkToMontage();
  });
}
if(returnToMontageBtn){
  returnToMontageBtn.addEventListener('click', ()=>{
    if(isPlaying) return;
    returnChunkToMontage();
  });
}

brushSize.addEventListener('input', ()=>{
  brush = Number(brushSize.value);
  brushSizeLabel.textContent = String(brush);
});

graySlider.addEventListener('input', ()=>{
  gray = Number(graySlider.value);
  grayLabel.textContent = String(gray);
});

onionSlider.addEventListener('input', ()=>{
  onionDepth = Number(onionSlider.value);
  onionLabel.textContent = String(onionDepth);
  if(!isPlaying) renderMain();
});

// Keyboard shortcuts
window.addEventListener('keydown', e=>{
  if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;

  // Undo/Redo
  const mod = e.ctrlKey || e.metaKey;
  if(mod && !isPlaying){
    const k = e.key.toLowerCase();
    if(k === 'z'){
      e.preventDefault();
      if(e.shiftKey) redo();
      else undo();
      return;
    }
    if(k === 'y'){
      e.preventDefault();
      redo();
      return;
    }
  }

  if(e.code === 'Space'){
    e.preventDefault();
    // Use appropriate play function based on current mode
    if(currentMode === 'montage'){
      if(montagePlaying) stopMontagePlayback(); else startMontagePlayback();
    }else{
      setPlaying(!isPlaying);
    }
    return;
  }

  // Frame navigation
  if(!isPlaying){
    if(e.key === '[' || e.code === 'ArrowLeft'){
      e.preventDefault();
      setCurrent(current - 1);
      return;
    }
    if(e.key === ']' || e.code === 'ArrowRight'){
      e.preventDefault();
      setCurrent(current + 1);
      return;
    }
  }

  // Delete current frame
  if(!isPlaying && (e.code === 'Delete' || e.code === 'Backspace')){
    e.preventDefault();
    deleteCurrentFrame();
    return;
  }

  const k = e.key.toLowerCase();
  // Do not run single-letter shortcuts when any modifier key is pressed — this avoids colliding
  // with browser or OS shortcuts like Ctrl/Cmd+S, Ctrl/Cmd+G, etc.
  const hasModifier = e.ctrlKey || e.metaKey || e.altKey || e.shiftKey;
  if(!hasModifier){
    if(k === 's'){
      if(!isPlaying){ e.preventDefault(); saveProject(); }
    }else if(k === 'g'){
      if(!isPlaying){ e.preventDefault(); saveGif(); }
    }else if(k === 'l'){
      if(!isPlaying){ e.preventDefault(); loadProjectInput.value = ''; loadProjectInput.click(); }
    }else if(k === 'n'){
      if(!isPlaying){
        e.preventDefault();
        frames = Array.from({length: 12}, ()=>makeBlankFrame());
        undoStacks = [];
        redoStacks = [];
        ensureStacks(frames.length);
        current = 0;
        initThumbs(false);
        renderAllThumbs();
        renderMain();
        updateUI();
      }
    }else if(k === 'a'){
      if(!isPlaying){ e.preventDefault(); addBlankAfterCurrent(); }
    }else if(k === 'd'){
      if(!isPlaying){ e.preventDefault(); duplicateAfterCurrent(); }
    }
  }
});

// -------------------- Montage UI helpers --------------------

// Montage in-memory model
let montageChunks = []; // {id,name,source:{type,ref|project}, frameRange:{start,end}, derived:boolean, _project:optional, alias:optional}
let montagePlaying = false;
let selectedChunkIdx = -1;
// Track editing context: which montage chunk is being edited in chunk editor
let _editingChunkContext = null; // { chunkIdx: number }

let _trimDragging = null;
let currentMode = 'chunk'; // 'chunk' | 'montage' - used to gate drawing and UI state
let _pendingInsertPosition = null; // null or number - position to insert next imported chunk
 // 'left'|'right' or null

function generateId(prefix='chunk'){
  return `${prefix}-${Date.now().toString(36)}-${Math.floor(Math.random()*0x10000).toString(16)}`;
}

// Helper function to ensure chunk has a valid alias
function ensureChunkAlias(chunk) {
  if (!chunk.alias || chunk.alias.trim() === '') {
    chunk.alias = chunk.name || generateId('cut');
  }
  return chunk.alias;
}

// append a small import log helper for Montage imports (visible in the Montage sidebar)
function addImportLog(msg){
  try{
    const el = document.getElementById('importLog');
    if(!el) return;
    const row = document.createElement('div');
    row.textContent = msg;
    el.appendChild(row);
    // keep last ~200 lines bounded
    while(el.children.length > 200) el.removeChild(el.firstChild);
    el.scrollTop = el.scrollHeight;
    console.debug('ImportLog:', msg);
  }catch(e){ console.error('addImportLog error', e); }
}

function computeMontageTotalFrames(){
  return montageChunks.reduce((s,ch)=> s + Math.max(0, (ch.frameRange && (ch.frameRange.end - ch.frameRange.start)) || 0), 0);
}

function updateMontageTimeDisplay(pos){
  const timeEl = document.getElementById('montageTimePos');
  if(timeEl && currentMode === 'montage'){
    const timeInSeconds = ((pos - 1) / FPS).toFixed(1);
    timeEl.textContent = `${timeInSeconds}s`;
  }
}

function updateMontageMetaUI(){
  const totalFrames = computeMontageTotalFrames();
  const el = document.getElementById('montageTotalFrames');
  if(el) el.textContent = String(totalFrames);
  
  // Update time position
  if(currentMode === 'montage'){
    const pos = Number(montageScrubber.value) || 1;
    updateMontageTimeDisplay(pos);
  }
}

function updateMontageScrubberUI(){
  const total = Math.max(1, computeMontageTotalFrames());
  const scrub = montageScrubber;
  if(!scrub) return;
  scrub.step = '1';
  scrub.max = String(total);

  // choose a sensible position depending on mode/play state/selection
  let pos = 1;
  if(currentMode === 'montage'){
    if(montagePlaying){
      let before = 0;
      for(let i=0;i<Math.min(_montagePos.chunkIdx, montageChunks.length); i++){
        const c = montageChunks[i]; before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0;
      }
      pos = Math.min(before + (_montagePos.frameIdx || 0) + 1, total);
    }else if(selectedChunkIdx >= 0){
      let before = 0;
      for(let i=0;i<selectedChunkIdx;i++){ const c = montageChunks[i]; before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0; }
      pos = Math.min(before + 1, total);
    }else{
      pos = 1;
    }
  }else{
    pos = clamp(current + 1, 1, total);
  }

  scrub.value = String(pos);
  const playPosEl = document.getElementById('montagePlayPos'); if(playPosEl) playPosEl.textContent = `${pos} / ${total}f`;
  
  // Update time display
  updateMontageTimeDisplay(pos);
  
  // Update rulers and chunk delimiters for montage mode
  if(currentMode === 'montage'){
    updateMontageRulers(total);
    updateChunkDelimiters(total);
  }
}

function updateMontageRulers(totalFrames){
  const topRuler = document.getElementById('scrubberTopRuler');
  const bottomRuler = document.getElementById('scrubberBottomRuler');
  if(!topRuler || !bottomRuler) return;
  
  // Show rulers in montage mode
  if(currentMode === 'montage'){
    topRuler.style.display = 'block';
    bottomRuler.style.display = 'block';
    
    // Top ruler: frame indices (show every ~10% of total or key positions)
    topRuler.innerHTML = '';
    const step = Math.max(1, Math.ceil(totalFrames / 8)); // Show ~8 markers
    for(let i = 0; i <= totalFrames; i += step){
      if(i === 0) continue; // Skip 0, start from 1
      const marker = document.createElement('span');
      marker.textContent = String(i);
      marker.style.position = 'absolute';
      marker.style.left = `${(i / totalFrames) * 100}%`;
      marker.style.transform = 'translateX(-50%)';
      topRuler.appendChild(marker);
    }
    
    // Bottom ruler: time in seconds (12 fps)
    bottomRuler.innerHTML = '';
    const totalSeconds = totalFrames / FPS;
    const timeStep = Math.max(0.5, Math.ceil(totalSeconds / 8) / 2) * 2; // Round to 0.5s increments
    for(let t = 0; t <= totalSeconds; t += timeStep){
      const marker = document.createElement('span');
      marker.textContent = `${t.toFixed(1)}s`;
      marker.style.position = 'absolute';
      marker.style.left = `${(t / totalSeconds) * 100}%`;
      marker.style.transform = 'translateX(-50%)';
      bottomRuler.appendChild(marker);
    }
  }else{
    topRuler.style.display = 'none';
    bottomRuler.style.display = 'none';
  }
}

function updateChunkDelimiters(totalFrames){
  const delimiters = document.getElementById('chunkDelimiters');
  if(!delimiters) return;
  
  if(currentMode === 'montage' && montageChunks.length > 0){
    delimiters.style.display = 'block';
    delimiters.innerHTML = '';
    
    // Add delimiter markers at chunk boundaries
    let cumulativeFrames = 0;
    for(let i = 0; i < montageChunks.length; i++){
      const chunk = montageChunks[i];
      const chunkLength = (chunk.frameRange && (chunk.frameRange.end - chunk.frameRange.start)) || 0;
      cumulativeFrames += chunkLength;
      
      // Add marker at end of chunk (unless it's the last chunk)
      if(i < montageChunks.length - 1 && cumulativeFrames > 0){
        const marker = document.createElement('div');
        marker.style.position = 'absolute';
        marker.style.left = `${(cumulativeFrames / totalFrames) * 100}%`;
        marker.style.top = '0';
        marker.style.bottom = '0';
        marker.style.width = '2px';
        marker.style.background = 'rgba(90,162,255,0.6)';
        marker.style.transform = 'translateX(-1px)';
        delimiters.appendChild(marker);
      }
    }
  }else{
    delimiters.style.display = 'none';
  }
}

function selectMontageChunk(idx, renderPreview = true){
  // clamp
  if(typeof idx !== 'number' || montageChunks.length === 0){ selectedChunkIdx = -1; }
  else selectedChunkIdx = clamp(idx, 0, montageChunks.length - 1);

  const container = document.getElementById('montageChunks');
  Array.from(container.children).forEach((child,i)=> child.classList.toggle('active', i === selectedChunkIdx));
  const ch = montageChunks[selectedChunkIdx];
  const trimBar = document.getElementById('trimBar');
  // show trim bar only in montage mode
  trimBar.style.display = (currentMode === 'montage') ? '' : 'none';

  const startInp = document.getElementById('trimStartInput');
  const endInp = document.getElementById('trimEndInput');
  const trimApply = document.getElementById('trimApplyBtn');
  const trimReset = document.getElementById('trimResetBtn');

  if(!ch){
    // no selection
    if(startInp) startInp.value = '';
    if(endInp) endInp.value = '';
    if(trimApply) trimApply.disabled = true;
    if(trimReset) trimReset.disabled = true;
    // clear trim bar handles
    updateTrimBar();
    // ensure canvas reflects current workspace
    if(currentMode === 'montage'){
      if(renderPreview) renderMontagePreviewChunk(-1);
      else {
        // keep canvas showing neutral blank when caller requested skipping preview render
        const blank = new Uint8Array(W*H); blank.fill(240); renderPreviewFrameBytes(blank);
      }
    } else { renderMain(); }
    return;
  }

  // set numeric inputs
  if(startInp) startInp.value = String(ch.frameRange.start);
  if(endInp) endInp.value = String(ch.frameRange.end);

  // enable apply/reset only if project data available
  const hasProject = !!ch._project;
  if(trimApply) trimApply.disabled = !hasProject;
  if(trimReset) trimReset.disabled = !hasProject;

  updateTrimBar();
  // update canvas preview when in montage mode unless caller asked to skip render
  if(currentMode === 'montage' && renderPreview){ renderMontagePreviewChunk(selectedChunkIdx); }
}

function updateTrimBar(){
  const c = document.getElementById('trimBarCanvas');
  if(!c) return;
  c.innerHTML = '';
  if(selectedChunkIdx < 0 || selectedChunkIdx >= montageChunks.length) return;
  const ch = montageChunks[selectedChunkIdx];
  if(!ch._project) return;
  const total = ch._project.frameCount || (ch._project.frames && ch._project.frames.length) || (ch.frameRange && ch.frameRange.end) || 0;
  if(total <= 0) return;

  // selection area
  const sel = document.createElement('div'); sel.className = 'trim-selection';
  const leftPercent = (ch.frameRange.start / total) * 100;
  const rightPercent = (ch.frameRange.end / total) * 100;
  sel.style.left = leftPercent + '%'; sel.style.width = (rightPercent - leftPercent) + '%';
  c.appendChild(sel);

  const leftH = document.createElement('div'); leftH.className = 'trim-handle'; leftH.style.left = `calc(${leftPercent}% - 5px)`;
  const rightH = document.createElement('div'); rightH.className = 'trim-handle'; rightH.style.left = `calc(${rightPercent}% - 5px)`;
  c.appendChild(leftH); c.appendChild(rightH);

  function toFrame(x){
    const rect = c.getBoundingClientRect(); const rel = clamp((x - rect.left) / rect.width, 0, 1); return Math.round(rel * total);
  }

  // pointer handlers for left/right handles
  leftH.addEventListener('pointerdown', (ev)=>{ ev.preventDefault(); _trimDragging = 'left'; leftH.setPointerCapture(ev.pointerId); });
  rightH.addEventListener('pointerdown', (ev)=>{ ev.preventDefault(); _trimDragging = 'right'; rightH.setPointerCapture(ev.pointerId); });

  // update visuals immediately (drag handlers use global pointer listeners)
  const leftPct = (ch.frameRange.start / total) * 100; const rightPct = (ch.frameRange.end / total) * 100;
  sel.style.left = leftPct + '%'; sel.style.width = (rightPct - leftPct) + '%'; leftH.style.left = `calc(${leftPct}% - 5px)`; rightH.style.left = `calc(${rightPct}% - 5px)`;
}

// Trim apply/reset buttons
const trimApplyBtnObs = function(){ const si = Number(document.getElementById('trimStartInput').value); const ei = Number(document.getElementById('trimEndInput').value); if(selectedChunkIdx>=0){ const ch = montageChunks[selectedChunkIdx]; ch.frameRange = {start: si, end: ei}; ch.derived = true; renderMontageChunks(); updateMontageMetaUI(); updateTrimBar(); updateMontageScrubberUI(); notify('Chunk trimmed (non-destructive).'); }};
const trimResetBtnObs = function(){ if(selectedChunkIdx>=0){ const ch = montageChunks[selectedChunkIdx]; ch.frameRange = {start:0, end: (ch._project && (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))) || ch.frameRange.end}; ch.derived = false; renderMontageChunks(); updateMontageMetaUI(); updateTrimBar(); updateMontageScrubberUI(); notify('Trim reset (restored full range).'); }};

// Global pointer handlers for draggable trim (single listeners to avoid accumulation)
function _globalTrimPointerMove(ev){ 
  if(!_trimDragging || selectedChunkIdx < 0) return; 
  const c = document.getElementById('trimBarCanvas'); 
  if(!c) return; 
  const ch = montageChunks[selectedChunkIdx]; 
  if(!ch._project) return; 
  const total = ch._project.frameCount || (ch._project.frames && ch._project.frames.length) || 0; 
  if(total <= 0) return; 
  const rect = c.getBoundingClientRect(); 
  const rel = clamp((ev.clientX - rect.left) / rect.width, 0, 1); 
  const f = Math.round(rel * total); 
  
  let frameToPreview = -1;
  if(_trimDragging === 'left'){ 
    const newStart = clamp(Math.min(f, ch.frameRange.end - 1), 0, total - 1); 
    ch.frameRange.start = newStart; 
    document.getElementById('trimStartInput').value = String(ch.frameRange.start);
    frameToPreview = newStart;
  }else if(_trimDragging === 'right'){ 
    const newEnd = clamp(Math.max(f, ch.frameRange.start + 1), 1, total); 
    ch.frameRange.end = newEnd; 
    document.getElementById('trimEndInput').value = String(ch.frameRange.end);
    frameToPreview = Math.max(0, newEnd - 1);
  } 
  
  updateTrimBar(); 
  
  // Show preview of the frame being trimmed
  if(frameToPreview >= 0 && frameToPreview < total){
    try{
      const bytes = _decodeFrameFromProject(ch._project, frameToPreview);
      const chunkInfo = {
        name: ch.name,
        alias: ch.alias,
        frameIdx: frameToPreview,
        totalFrames: total
      };
      renderPreviewFrameBytes(bytes, chunkInfo);
    }catch(e){
      console.error('Failed to preview frame during trim', e);
    }
  }
}
function _globalTrimPointerUp(ev){ if(!_trimDragging) return; _trimDragging = null; renderMontageChunks(); updateMontageMetaUI(); updateMontageScrubberUI(); notify('Chunk trimmed (non-destructive).'); }
window.addEventListener('pointermove', _globalTrimPointerMove);
window.addEventListener('pointerup', _globalTrimPointerUp);

// wire buttons when DOM ready (guard)
window.addEventListener('DOMContentLoaded', ()=>{
  const a = document.getElementById('trimApplyBtn'); if(a) a.addEventListener('click', trimApplyBtnObs);
  const r = document.getElementById('trimResetBtn'); if(r) r.addEventListener('click', trimResetBtnObs);

  // wire editor toggle buttons here to ensure they exist and to add safe handlers
  const tc = document.getElementById('toggleChunk'); if(tc) tc.addEventListener('click', ()=> { console.debug('toggleChunk clicked'); setMode('chunk'); });
  const tm = document.getElementById('toggleMontage'); if(tm) tm.addEventListener('click', ()=> { console.debug('toggleMontage clicked'); setMode('montage'); });

});

function setMode(mode){
  const isMontage = mode === 'montage';
  const newMode = isMontage ? 'montage' : 'chunk';
  if(currentMode === newMode){ console.debug('setMode: already', currentMode); return; }
  currentMode = newMode;
  console.debug('setMode ->', currentMode);
  notify(`Switched to ${currentMode === 'montage' ? 'Montage Editor' : 'Chunk Editor'}`);

  // Update header hint text based on mode
  const headerHint = document.getElementById('headerHint');
  if(headerHint){
    if(isMontage){
      headerHint.textContent = 'Space play/pause · Click chunk to select · Drag trim handles to adjust range · Import chunks to assemble montage';
    }else{
      headerHint.textContent = 'Space play/pause · [ / ] or ←/→ prev/next · A add frame · D duplicate · Del delete frame · Ctrl/Cmd+Z undo · Ctrl/Cmd+Y redo · S save · G GIF · L load · N new';
    }
  }

  document.getElementById('montageSidebar').style.display = isMontage ? '' : 'none';
  // hide the frames sidebar when in montage mode
  const framesSidebar = document.querySelector('.sidebar');
  // the frames sidebar is the first .sidebar; when montage is active we still want it hidden.
  if(framesSidebar) framesSidebar.style.display = isMontage ? 'none' : '';
  document.getElementById('toggleChunk').classList.toggle('primary', !isMontage);
  document.getElementById('toggleMontage').classList.toggle('primary', isMontage);

  // trim bar should be visible only in montage mode
  const trimBar = document.getElementById('trimBar'); if(trimBar) trimBar.style.display = isMontage ? '' : 'none';

  // show appropriate play button based on mode
  if(playBtn) playBtn.style.display = isMontage ? 'none' : '';
  if(montagePlayBtn) montagePlayBtn.style.display = isMontage ? '' : 'none';

  // hide drawing panel in montage mode
  const drawingPanel = document.getElementById('drawingPanel'); if(drawingPanel) drawingPanel.style.display = isMontage ? 'none' : '';

  // disable drawing/frame-edit controls while in montage mode
  const drawingControls = [toolPencil, toolEraser, toolSoft, undoBtn, redoBtn, addFrameBtn, dupFrameBtn, delFrameBtn, brushSize, graySlider, onionSlider];
  drawingControls.forEach(el => { if(el) el.disabled = isMontage; });

  // select first chunk when entering montage mode
  if(isMontage && montageChunks.length > 0 && selectedChunkIdx === -1){ selectMontageChunk(0); }

  if(isMontage){
    // render preview for the selected chunk (or blank preview)
    renderMontagePreviewChunk(selectedChunkIdx);
    // show montage scrubber and set its range
    if(montageScrubber){ 
      montageScrubber.style.display = '';
      montageScrubber.step = '1';
      montageScrubber.max = String(Math.max(1, computeMontageTotalFrames()));
      if(selectedChunkIdx >= 0){ 
        let before = 0; for(let i=0;i<selectedChunkIdx;i++){ const c = montageChunks[i]; before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0; }
        montageScrubber.value = String(before + 1);
      }
    }
    // Show montage info
    const montageInfo = document.getElementById('montageInfo');
    if(montageInfo) montageInfo.style.display = 'block';
    // Show rulers and chunk delimiters
    updateMontageRulers(Math.max(1, computeMontageTotalFrames()));
    updateChunkDelimiters(Math.max(1, computeMontageTotalFrames()));
    updateMontageMetaUI();
    main.style.cursor = 'default';
    updateMontageIntegrationButtons();
  }else{
    // restore chunk editor view and cursor
    renderMain();
    if(montageScrubber) {
      montageScrubber.style.display = '';
      montageScrubber.step = '1';
      montageScrubber.max = String(frames.length);
      montageScrubber.value = String(current + 1);
    }
    // Hide montage info
    const montageInfo = document.getElementById('montageInfo');
    if(montageInfo) montageInfo.style.display = 'none';
    // Hide rulers and chunk delimiters
    const topRuler = document.getElementById('scrubberTopRuler');
    const bottomRuler = document.getElementById('scrubberBottomRuler');
    const delimiters = document.getElementById('chunkDelimiters');
    if(topRuler) topRuler.style.display = 'none';
    if(bottomRuler) bottomRuler.style.display = 'none';
    if(delimiters) delimiters.style.display = 'none';
    main.style.cursor = 'crosshair';
    updateMontageIntegrationButtons();
  }
} 

function addMontageChunk(obj, insertPosition = null){
  if(insertPosition !== null && typeof insertPosition === 'number'){
    // Insert at specific position
    const pos = clamp(insertPosition, 0, montageChunks.length);
    montageChunks.splice(pos, 0, obj);
  }else{
    // Default: append at end
    montageChunks.push(obj);
  }
  renderMontageChunks();
  updateMontageMetaUI();
  updateMontageScrubberUI();
  // select first chunk by default when first chunk added
  if(montageChunks.length === 1){ selectMontageChunk(0); }
}

// -------------------- Chunk/Montage Editor Integration --------------------
// Edit a montage chunk in the chunk editor
function editChunkInChunkEditor(chunkIdx){
  if(chunkIdx < 0 || chunkIdx >= montageChunks.length) return;
  const chunk = montageChunks[chunkIdx];
  
  if(!chunk._project || !chunk._project.frames){
    notify('Chunk project data not available');
    return;
  }
  
  // Store editing context
  _editingChunkContext = { chunkIdx };
  
  // Load chunk frames into chunk editor
  const project = chunk._project;
  const frameCount = project.frameCount || (project.frames && project.frames.length) || 0;
  
  frames = Array.from({length: frameCount}, ()=>makeBlankFrame());
  undoStacks = [];
  redoStacks = [];
  ensureStacks(frameCount);
  
  for(let i=0; i<frameCount; i++){
    if(i < project.frames.length){
      const base64 = project.frames[i];
      const binary = atob(base64);
      const arr = new Uint8Array(binary.length);
      for(let j=0; j<binary.length; j++) arr[j] = binary.charCodeAt(j);
      frames[i].set(arr);
    }
  }
  
  // Switch to chunk editor
  setMode('chunk');
  initThumbs(false);
  setCurrent(chunk.frameRange.start);
  renderAllThumbs();
  renderMain();
  updateUI();
  
  // Show "Return to Montage" button
  updateMontageIntegrationButtons();
  notify(`Editing chunk: ${chunk.alias || chunk.name}`);
}

// Insert current chunk editor project to montage
function insertChunkToMontage(){
  if(frames.length === 0){
    notify('No frames to insert');
    return;
  }
  
  // Create project from current frames
  const project = {
    version: '1.3',
    width: W,
    height: H,
    fps: FPS,
    frameCount: frames.length,
    timestamp: new Date().toISOString(),
    frames: frames.map(f=>{
      let binary = '';
      for(let i=0;i<f.length;i++) binary += String.fromCharCode(f[i]);
      return btoa(binary);
    })
  };
  
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  const chunkName = lastProjectPath || `chunk-${ts}`;
  const ch = {
    id: generateId('chunk'),
    name: chunkName,
    alias: chunkName.replace(/\.json$/i, ''),
    source: {type:'embedded', project: project},
    frameRange: {start:0, end: frames.length},
    derived: false,
    _project: project
  };
  
  // Switch to montage editor and add chunk
  setMode('montage');
  addMontageChunk(ch);
  notify(`Inserted chunk to montage`);
}

// Return edited chunk to montage
function returnChunkToMontage(){
  if(!_editingChunkContext){
    notify('No montage context to return to');
    return;
  }
  
  // Update chunk with edited frames
  const { chunkIdx } = _editingChunkContext;
  
  // Create updated project from current frames
  const project = {
    version: '1.3',
    width: W,
    height: H,
    fps: FPS,
    frameCount: frames.length,
    timestamp: new Date().toISOString(),
    frames: frames.map(f=>{
      let binary = '';
      for(let i=0;i<f.length;i++) binary += String.fromCharCode(f[i]);
      return btoa(binary);
    })
  };
  
  // Update the chunk
  if(chunkIdx >= 0 && chunkIdx < montageChunks.length){
    const chunk = montageChunks[chunkIdx];
    chunk._project = project;
    chunk.source = {type:'embedded', project: project};
    // Update frame range if frame count changed
    if(frames.length !== chunk.frameRange.end){
      chunk.frameRange.end = frames.length;
    }
  }
  
  // Clear editing context
  _editingChunkContext = null;
  
  // Switch back to montage
  setMode('montage');
  renderMontageChunks();
  updateMontageMetaUI();
  updateMontageScrubberUI();
  updateMontageIntegrationButtons();
  notify('Chunk updated in montage');
}

// Update visibility of montage integration buttons
function updateMontageIntegrationButtons(){
  const insertBtn = document.getElementById('insertToMontageBtn');
  const returnBtn = document.getElementById('returnToMontageBtn');
  
  if(currentMode === 'chunk'){
    // Show insert button if not editing from montage
    if(insertBtn) insertBtn.style.display = _editingChunkContext ? 'none' : '';
    // Show return button if editing from montage
    if(returnBtn) returnBtn.style.display = _editingChunkContext ? '' : 'none';
  }else{
    // Hide both in montage mode
    if(insertBtn) insertBtn.style.display = 'none';
    if(returnBtn) returnBtn.style.display = 'none';
  }
}

// Extract thumbnail frame index from chunk - picks a frame a few frames in for better representation
function getChunkThumbnailFrameIndex(chunk){
  const start = chunk.frameRange.start || 0;
  const end = chunk.frameRange.end || 0;
  const frameCount = end - start;
  
  if(frameCount <= 3) return start; // too short, use first frame
  
  // Pick frame at ~15% into the chunk, or frame 3-5, whichever is smaller
  const offset = Math.min(5, Math.floor(frameCount * 0.15));
  return start + offset;
}

function renderMontageChunks(){
  const container = document.getElementById('montageChunks');
  container.innerHTML = '';
  
  // Helper function to create insert button
  function createInsertZone(insertIdx, label){
    const zone = document.createElement('div');
    zone.className = 'chunk-insert-zone';
    const btn = document.createElement('button');
    btn.textContent = label;
    btn.title = `Click to insert imported chunk at position ${insertIdx}`;
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      // Trigger import and insert at specific position
      _pendingInsertPosition = insertIdx;
      montageImportInputEl.click();
    });
    zone.appendChild(btn);
    return zone;
  }
  
  // Add "Insert at beginning" button if there are chunks
  if(montageChunks.length > 0){
    container.appendChild(createInsertZone(0, '+ Insert at beginning'));
  }
  
  montageChunks.forEach((ch, idx)=>{
    const div = document.createElement('div');
    div.className = 'chunk-item';
    div.title = ch.name; // Show full filename on hover

    // Thumbnail
    const thumb = document.createElement('div');
    thumb.className = 'chunk-thumb';
    if(ch._project && ch._project.frames && ch._project.frames.length > 0){
      try{
        const thumbCanvas = document.createElement('canvas');
        const thumbFrameIdx = getChunkThumbnailFrameIndex(ch);
        const w = ch._project.width || W;
        const h = ch._project.height || H;
        thumbCanvas.width = 48;
        thumbCanvas.height = 48;
        const thumbCtx = thumbCanvas.getContext('2d', { alpha:false });
        thumbCtx.imageSmoothingEnabled = false;
        
        // Decode frame bytes and render to thumbnail
        const frameBytes = _decodeFrameFromProject(ch._project, thumbFrameIdx);
        const imgData = new Uint8ClampedArray(w * h * 4);
        for(let p=0, o=0; p<frameBytes.length; p++, o+=4){
          const v = frameBytes[p];
          imgData[o] = v; imgData[o+1] = v; imgData[o+2] = v; imgData[o+3] = 255;
        }
        
        // Create temporary canvas for source frame
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = w;
        tempCanvas.height = h;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(new ImageData(imgData, w, h), 0, 0);
        
        // Scale to thumbnail size
        thumbCtx.drawImage(tempCanvas, 0, 0, 48, 48);
        thumb.appendChild(thumbCanvas);
      }catch(e){
        console.error('Failed to render chunk thumbnail', ch.name, e);
        thumb.textContent = '🎬';
      }
    } else {
      thumb.textContent = '🎬';
    }
    div.appendChild(thumb);

    // Info section
    const info = document.createElement('div');
    info.className = 'chunk-info';

    // Badges
    const badges = document.createElement('div');
    badges.className = 'chunk-badges';
    const durationBadge = document.createElement('span'); 
    durationBadge.className = 'pill'; 
    durationBadge.textContent = `${(ch.frameRange.end - ch.frameRange.start)}f`;
    badges.appendChild(durationBadge);
    info.appendChild(badges);

    // Alias input (now labeled as "Cut Name")
    const aliasInput = document.createElement('input');
    aliasInput.type = 'text';
    aliasInput.className = 'chunk-alias';
    aliasInput.placeholder = 'Cut name';
    aliasInput.value = ensureChunkAlias(ch);
    aliasInput.addEventListener('input', (e)=>{
      e.stopPropagation();
      const newValue = aliasInput.value.trim();
      ch.alias = newValue || ch.name || generateId('cut');
      updateMontageScrubberUI();
    });
    aliasInput.addEventListener('click', (e)=>e.stopPropagation());
    info.appendChild(aliasInput);

    div.appendChild(info);

    // Controls section
    const controls = document.createElement('div');
    controls.className = 'chunk-controls';

    // events: select on click
    div.addEventListener('click', ()=>{ selectMontageChunk(idx); });

    const editBtn = document.createElement('button'); editBtn.className = 'iconBtn'; editBtn.title = 'Edit in Chunk Editor'; editBtn.textContent = '✎';
    editBtn.addEventListener('click', (e)=>{ e.stopPropagation(); editChunkInChunkEditor(idx); });

    const upBtn = document.createElement('button'); upBtn.className = 'iconBtn'; upBtn.title = 'Move Up'; upBtn.textContent = '▴';
    upBtn.addEventListener('click', (e)=>{ e.stopPropagation(); if(idx === 0) return; [montageChunks[idx-1], montageChunks[idx]] = [montageChunks[idx], montageChunks[idx-1]]; renderMontageChunks(); updateMontageMetaUI(); updateMontageScrubberUI(); });

    const downBtn = document.createElement('button'); downBtn.className = 'iconBtn'; downBtn.title = 'Move Down'; downBtn.textContent = '▾';
    downBtn.addEventListener('click', (e)=>{ e.stopPropagation(); if(idx === montageChunks.length-1) return; [montageChunks[idx+1], montageChunks[idx]] = [montageChunks[idx], montageChunks[idx+1]]; renderMontageChunks(); updateMontageMetaUI(); updateMontageScrubberUI(); });

    const delBtn = document.createElement('button'); delBtn.className = 'iconBtn danger'; delBtn.title = 'Delete'; delBtn.textContent = '✖';
    delBtn.addEventListener('click', (e)=>{ e.stopPropagation(); montageChunks.splice(idx,1); renderMontageChunks(); updateMontageMetaUI(); updateMontageScrubberUI(); });

    controls.appendChild(editBtn);
    controls.appendChild(upBtn);
    controls.appendChild(downBtn);
    controls.appendChild(delBtn);

    div.appendChild(controls);

    div.addEventListener('dblclick', (e)=>{ // on dblclick select and focus alias input
      e.stopPropagation();
      selectMontageChunk(idx);
      aliasInput.focus();
      aliasInput.select();
    });

    container.appendChild(div);
    
    // Add insertion zone after this chunk
    container.appendChild(createInsertZone(idx + 1, '+ Insert here'));
  });
}

// Wire up UI controls for Montage
const toggleChunkBtn = document.getElementById('toggleChunk');
const toggleMontageBtn = document.getElementById('toggleMontage');
const montageImportBtn = document.getElementById('montageImportBtn');
const montageImportInputEl = document.getElementById('montageImportInput');
const montageLoadBtn = document.getElementById('montageLoadBtn');
const montageLoadInputEl = document.getElementById('montageLoadInput');
const saveMontageBtn = document.getElementById('saveMontageBtn');
const montagePlayBtn = document.getElementById('montagePlayBtn');

// Default mode is chunk editor
setMode('chunk');

// toggle event handlers are wired on DOMContentLoaded to ensure elements exist
montageImportBtn.addEventListener('click', ()=> {
  _pendingInsertPosition = null; // Clear pending position when using main import button
  montageImportInputEl.click();
});

montageImportInputEl.addEventListener('change', (ev)=>{
  const files = Array.from(ev.target.files || []);
  if(files.length === 0) return;
  
  // Capture insert position for this batch of imports
  const insertPos = _pendingInsertPosition;
  let actualInsertPos = insertPos;
  
  files.forEach((f, fileIdx) => {
    const fr = new FileReader();
    fr.onload = async ()=>{
      try{
        let json;
        try{ json = JSON.parse(String(fr.result)); }catch(err){ throw new Error(`Failed to parse ${f.name}: ${err.message}`); }

        // basic validation: width/height/fps match current project
        if(json.width !== W || json.height !== H || json.fps !== FPS){
          throw new Error(`Skipped ${f.name}: width/height/fps mismatch (got ${json.width}x${json.height}@${json.fps})`);
        }

        // use shared validation helper for consistent checks
        if(typeof validateProject !== 'function') throw new Error('Validation function not available');
        const vres = validateProject(json, { width: W, height: H, fps: FPS });
        if(!vres.ok) throw new Error(`${f.name} failed validation: ${vres.errors.join('; ')}`);

        let refVal = f.name;
        // try to set canonical example/ path if accessible (only when served over http(s))
        try{
          if(location && location.protocol && (location.protocol === 'http:' || location.protocol === 'https:')){
            const resp = await fetch(`example/${f.name}`);
            if(resp.ok) refVal = `example/${f.name}`;
          }
        }catch(_){ /* ignore */ }

        const ch = {
          id: generateId('chunk'),
          name: f.name.replace(/\.json$/i, ''),
          alias: f.name.replace(/\.json$/i, ''),
          source: {type:'embedded', project: json},
          frameRange: {start:0, end: (json.frameCount || (json.frames && json.frames.length) || 0)},
          derived: false,
          _project: json
        };
        
        // Insert at the specified position, incrementing for multiple files
        const currentInsertPos = (actualInsertPos !== null) ? (actualInsertPos + fileIdx) : null;
        addMontageChunk(ch, currentInsertPos);
        
        // if no selection yet, select this chunk
        if(selectedChunkIdx === -1) selectMontageChunk(0);
        notify(`Imported ${f.name}`);
        addImportLog(`${f.name}: Imported`);
      }catch(err){
        notify(err.message || String(err));
        console.error('Import error:', f.name, err);
        addImportLog(`${f.name}: Error - ${err.message || String(err)}`);
      }
    };
    fr.onerror = (e)=>{ notify(`Failed to read ${f.name}`); console.error('FileReader error', f.name, e); addImportLog(`${f.name}: Read error`); };
    fr.readAsText(f);
  });
  // clear input so same file can be reselected
  montageImportInputEl.value = '';
  // Clear pending insert position after import is initiated
  _pendingInsertPosition = null;
});

saveMontageBtn.addEventListener('click', ()=>{
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  const defaultName = lastMontagePath || `montage-${ts}.json`;
  const filename = promptForFilename(defaultName, 'montage');
  if(!filename) return; // User cancelled
  
  const out = {
    version: 'montage-1.0', width: W, height: H, fps: FPS, timestamp: new Date().toISOString(), chunks: []
  };
  montageChunks.forEach(ch => {
    const item = { id: ch.id, name: ch.name, frameRange: ch.frameRange, derived: !!ch.derived };
    if(ch.alias) item.alias = ch.alias;
    if(ch.source && ch.source.type === 'embedded') item.source = { type: 'embedded', project: ch.source.project };
    else if(ch.source && ch.source.type === 'reference') item.source = { type: 'reference', ref: ch.source.ref };
    out.chunks.push(item);
  });
  const blob = new Blob([JSON.stringify(out, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename.endsWith('.json') ? filename : `${filename}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  notify(`Montage saved as ${a.download}`);
});

// Load Montage from JSON
if(montageLoadBtn && montageLoadInputEl){
  montageLoadBtn.addEventListener('click', ()=>{
    montageLoadInputEl.value = '';
    montageLoadInputEl.click();
  });
  
  montageLoadInputEl.addEventListener('change', async (ev)=>{
    const file = ev.target.files && ev.target.files[0];
    if(!file) return;
    
    try{
      const text = await file.text();
      let montageJson;
      try{ montageJson = JSON.parse(text); }catch(err){ throw new Error(`Failed to parse montage JSON: ${err.message}`); }
      
      // Validate montage structure
      if(!montageJson || montageJson.version !== 'montage-1.0'){
        throw new Error('Invalid montage file format');
      }
      if(montageJson.width !== W || montageJson.height !== H || montageJson.fps !== FPS){
        throw new Error(`Montage dimensions/fps mismatch (got ${montageJson.width}x${montageJson.height}@${montageJson.fps})`);
      }
      if(!Array.isArray(montageJson.chunks)){
        throw new Error('Invalid montage file: missing chunks array');
      }
      
      // Clear existing chunks
      montageChunks = [];
      
      // Load each chunk
      for(const chunkData of montageJson.chunks){
        let project = null;
        
        if(chunkData.source && chunkData.source.type === 'embedded'){
          // Embedded project
          project = chunkData.source.project;
        }else if(chunkData.source && chunkData.source.type === 'reference'){
          // Try to load referenced project
          try{
            const resp = await fetch(chunkData.source.ref);
            if(resp.ok){
              project = await resp.json();
            }else{
              console.warn(`Failed to load referenced chunk: ${chunkData.source.ref}`);
            }
          }catch(err){
            console.warn(`Failed to fetch chunk reference: ${chunkData.source.ref}`, err);
          }
        }
        
        const ch = {
          id: chunkData.id || generateId('chunk'),
          name: chunkData.name,
          source: chunkData.source,
          frameRange: chunkData.frameRange || {start:0, end:0},
          derived: !!chunkData.derived,
          _project: project,
          alias: chunkData.alias || chunkData.name || generateId('cut')
        };
        
        montageChunks.push(ch);
      }
      
      renderMontageChunks();
      updateMontageMetaUI();
      updateMontageScrubberUI();
      if(montageChunks.length > 0) selectMontageChunk(0);
      
      // Store filename for future saves
      lastMontagePath = file.name;
      notify(`Loaded ${file.name} with ${montageChunks.length} chunks`);
    }catch(err){
      notify(`Failed to load montage: ${err.message}`);
      console.error('Load montage error:', err);
    }
  });
}


// Export montage as GIF
const exportMontageGifBtn = document.getElementById('exportMontageGifBtn');
if(exportMontageGifBtn){
  exportMontageGifBtn.addEventListener('click', async ()=>{
    if(montageChunks.length === 0){
      notify('No chunks to export');
      return;
    }
    
    // Collect all frames from all chunks
    const allFrames = [];
    for(const ch of montageChunks){
      if(!ch._project || !ch._project.frames) continue;
      const start = ch.frameRange.start || 0;
      const end = ch.frameRange.end || 0;
      for(let i = start; i < end; i++){
        if(i >= ch._project.frames.length) break;
        try{
          const frameBytes = _decodeFrameFromProject(ch._project, i);
          allFrames.push(frameBytes);
        }catch(e){
          console.error('Failed to decode frame', i, 'from chunk', ch.name, e);
        }
      }
    }
    
    if(allFrames.length === 0){
      notify('No frames to export');
      return;
    }
    
    setExporting(true);
    try{
      const workerUrl = await getGifWorkerBlobUrl();
      
      const gif = new GIF({
        workers: 2,
        quality: 10,
        width: DISPLAY,
        height: DISPLAY,
        repeat: 0,
        workerScript: workerUrl
      });
      
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = DISPLAY;
      exportCanvas.height = DISPLAY;
      const ectx = exportCanvas.getContext('2d', { alpha:false });
      ectx.imageSmoothingEnabled = false;
      
      const delay = Math.round(1000 / FPS);
      
      for(let i=0; i<allFrames.length; i++){
        const frameBytes = allFrames[i];
        const imgData = new Uint8ClampedArray(W*H*4);
        for(let p=0, o=0; p<frameBytes.length; p++, o+=4){
          const v = frameBytes[p];
          imgData[o]=v; imgData[o+1]=v; imgData[o+2]=v; imgData[o+3]=255;
        }
        offCtx.putImageData(new ImageData(imgData, W, H), 0, 0);
        
        ectx.setTransform(1,0,0,1,0,0);
        ectx.clearRect(0,0,DISPLAY,DISPLAY);
        ectx.fillStyle = '#ffffff';
        ectx.fillRect(0,0,DISPLAY,DISPLAY);
        
        ectx.imageSmoothingEnabled = false;
        ectx.drawImage(off, 0, 0, DISPLAY, DISPLAY);
        
        gif.addFrame(exportCanvas, { copy:true, delay });
      }
      
      await new Promise((resolve, reject)=>{
        gif.on('finished', blob => {
          const a = document.createElement('a');
          const ts = new Date().toISOString().replace(/[:.]/g,'-');
          a.download = `montage-${ts}.gif`;
          a.href = URL.createObjectURL(blob);
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
          
          if(workerUrl && workerUrl.startsWith('blob:')){
            try{ URL.revokeObjectURL(workerUrl); }catch(_){ }
            if(workerUrl === _gifWorkerBlobUrl) _gifWorkerBlobUrl = null;
          }
          
          setExporting(false);
          notify('Montage GIF exported.');
          resolve();
        });
        
        gif.on('error', err => {
          console.error('GIF render error', err);
          notify(`Failed to render GIF: ${err && err.message ? err.message : String(err)}`);
          if(workerUrl && workerUrl.startsWith('blob:')){
            try{ URL.revokeObjectURL(workerUrl); }catch(_){ }
            if(workerUrl === _gifWorkerBlobUrl) _gifWorkerBlobUrl = null;
          }
          setExporting(false);
          reject(err);
        });
        
        gif.render();
      });
    }catch(err){
      console.error('exportMontageGif error', err);
      notify(`Failed to export GIF: ${err && err.message ? err.message : String(err)}`);
      setExporting(false);
    }
  });
}

// Export montage as MP4
const exportMontageMp4Btn = document.getElementById('exportMontageMp4Btn');
if(exportMontageMp4Btn){
  exportMontageMp4Btn.addEventListener('click', async ()=>{
    if(montageChunks.length === 0){
      notify('No chunks to export');
      return;
    }
    
    // Check if MediaRecorder is supported
    if(!window.MediaRecorder || !HTMLCanvasElement.prototype.captureStream){
      notify('MP4 export not supported in this browser. Try Chrome or Firefox.');
      return;
    }
    
    // Collect all frames
    const allFrames = [];
    for(const ch of montageChunks){
      if(!ch._project || !ch._project.frames) continue;
      const start = ch.frameRange.start || 0;
      const end = ch.frameRange.end || 0;
      for(let i = start; i < end; i++){
        if(i >= ch._project.frames.length) break;
        try{
          const frameBytes = _decodeFrameFromProject(ch._project, i);
          allFrames.push(frameBytes);
        }catch(e){
          console.error('Failed to decode frame', i, 'from chunk', ch.name, e);
        }
      }
    }
    
    if(allFrames.length === 0){
      notify('No frames to export');
      return;
    }
    
    setExporting(true);
    try{
      // Create a canvas for recording
      const recordCanvas = document.createElement('canvas');
      recordCanvas.width = DISPLAY;
      recordCanvas.height = DISPLAY;
      const rctx = recordCanvas.getContext('2d', { alpha:false });
      rctx.imageSmoothingEnabled = false;
      
      // Get canvas stream
      const stream = recordCanvas.captureStream(FPS);
      
      // Determine MIME type
      let mimeType = 'video/webm;codecs=vp9';
      if(!MediaRecorder.isTypeSupported(mimeType)){
        mimeType = 'video/webm;codecs=vp8';
        if(!MediaRecorder.isTypeSupported(mimeType)){
          mimeType = 'video/webm';
        }
      }
      
      const chunks = [];
      const recorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 2500000 });
      
      recorder.ondataavailable = (e)=>{ if(e.data && e.data.size > 0) chunks.push(e.data); };
      
      recorder.onstop = ()=>{
        const blob = new Blob(chunks, { type: mimeType });
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g,'-');
        const ext = mimeType.includes('mp4') ? 'mp4' : 'webm';
        a.download = `montage-${ts}.${ext}`;
        a.href = URL.createObjectURL(blob);
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
        setExporting(false);
        notify(`Montage video exported as ${ext.toUpperCase()}.`);
      };
      
      recorder.onerror = (e)=>{
        console.error('MediaRecorder error', e);
        notify('Failed to record video');
        setExporting(false);
      };
      
      recorder.start();
      
      // Render frames at the correct frame rate
      const frameDelay = Math.round(1000 / FPS);
      let frameIdx = 0;
      
      const renderNextFrame = ()=>{
        if(frameIdx >= allFrames.length){
          // Done rendering all frames - stop recorder
          recorder.stop();
          return;
        }
        
        const frameBytes = allFrames[frameIdx];
        const imgData = new Uint8ClampedArray(W*H*4);
        for(let p=0, o=0; p<frameBytes.length; p++, o+=4){
          const v = frameBytes[p];
          imgData[o]=v; imgData[o+1]=v; imgData[o+2]=v; imgData[o+3]=255;
        }
        offCtx.putImageData(new ImageData(imgData, W, H), 0, 0);
        
        rctx.setTransform(1,0,0,1,0,0);
        rctx.clearRect(0,0,DISPLAY,DISPLAY);
        rctx.fillStyle = '#ffffff';
        rctx.fillRect(0,0,DISPLAY,DISPLAY);
        rctx.imageSmoothingEnabled = false;
        rctx.drawImage(off, 0, 0, DISPLAY, DISPLAY);
        
        frameIdx++;
        setTimeout(renderNextFrame, frameDelay);
      };
      
      // Start rendering frames
      renderNextFrame();
      
    }catch(err){
      console.error('exportMontageMp4 error', err);
      notify(`Failed to export MP4: ${err && err.message ? err.message : String(err)}`);
      setExporting(false);
    }
  });
}


let _montageTimer = null;
let _montagePos = { chunkIdx: 0, frameIdx: 0 };

function renderPreviewFrameBytes(bytes, chunkInfo = null){
  // bytes: Uint8Array of length W*H
  // chunkInfo: {name, alias, frameIdx, totalFrames} - optional chunk info for overlay
  const out = new Uint8ClampedArray(W*H*4);
  for(let p=0,o=0; p<bytes.length; p++,o+=4){ const v = bytes[p]; out[o]=v; out[o+1]=v; out[o+2]=v; out[o+3]=255; }
  const id = new ImageData(out, W, H);
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const target = DISPLAY * dpr;
  if(main.width !== target || main.height !== target){ main.width = target; main.height = target; }
  offCtx.putImageData(id, 0, 0);
  ctx.clearRect(0,0, main.width, main.height);
  ctx.drawImage(off, 0, 0, main.width, main.height);
  
  // Render chunk info overlay if in montage mode
  if(chunkInfo && currentMode === 'montage'){
    ctx.save();
    ctx.font = '14px sans-serif';
    const displayName = chunkInfo.alias || chunkInfo.name;
    const frameInfo = `${chunkInfo.frameIdx + 1}/${chunkInfo.totalFrames}`;
    const text = `${displayName} (${frameInfo})`;
    
    // Measure text for background
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    const textHeight = 14;
    const padding = 6;
    
    // Draw semi-transparent background
    ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
    ctx.fillRect(8, 8, textWidth + padding * 2, textHeight + padding * 2);
    
    // Draw text
    ctx.fillStyle = 'rgba(230, 230, 230, 0.95)';
    ctx.fillText(text, 8 + padding, 8 + padding + textHeight - 2);
    ctx.restore();
  }
}

function _decodeFrameFromProject(project, idx){
  const base64 = project.frames[idx];
  const binary = atob(base64);
  const arr = new Uint8Array(binary.length);
  for(let j=0;j<binary.length;j++) arr[j] = binary.charCodeAt(j);
  return arr;
}

// Render a read-only preview for a montage chunk into the main canvas
function renderMontagePreviewChunk(idx){
  const ch = montageChunks[idx];
  if(!ch){
    // no selection: show editor view when in chunk mode, otherwise clear preview
    if(currentMode === 'chunk'){ renderMain(); return; }
    const blank = new Uint8Array(W*H); blank.fill(240); renderPreviewFrameBytes(blank); return;
  }

  if(ch._project && Array.isArray(ch._project.frames) && ch.frameRange && ch.frameRange.start < ch._project.frames.length){
    try{
      const bytes = _decodeFrameFromProject(ch._project, ch.frameRange.start);
      const chunkInfo = {
        name: ch.name,
        alias: ch.alias,
        frameIdx: ch.frameRange.start,
        totalFrames: (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))
      };
      renderPreviewFrameBytes(bytes, chunkInfo);
      return;
    }catch(e){ console.error('Preview render failed', e); }
  }

  // fallback: neutral blank with message
  const blank = new Uint8Array(W*H); blank.fill(240); renderPreviewFrameBytes(blank);
  ctx.save();
  ctx.fillStyle = 'rgba(180,180,180,0.9)';
  ctx.font = '14px sans-serif';
  ctx.fillText(ch.name ? `${ch.name} (no project loaded)` : 'No preview', 8, 18);
  ctx.restore();
}

function startMontagePlayback(){
  if(montageChunks.length === 0) { notify('No chunks to play'); return; }
  // Don't reset position - resume from current position
  montagePlaying = true; montagePlayBtn.textContent = 'Pause';

  // init playback UI
  const playPosEl = document.getElementById('montagePlayPos');

  // remember last highlighted chunk so we only update selection on chunk change (avoids overwriting the current preview)
  let lastChunkIdx = -1;

  _montageTimer = setInterval(()=>{
    // out-of-range -> stop playback
    if(_montagePos.chunkIdx >= montageChunks.length){ stopMontagePlayback(); return; }
    const ch = montageChunks[_montagePos.chunkIdx];
    const total = (ch.frameRange && (ch.frameRange.end - ch.frameRange.start)) || 0;
    if(total <= 0){ _montagePos.chunkIdx++; _montagePos.frameIdx = 0; return; }

    // ensure project loaded
    if(!ch._project){ notify('Project data not loaded for chunk: ' + ch.name); stopMontagePlayback(); return; }
    const frameInSource = ch.frameRange.start + _montagePos.frameIdx;
    if(frameInSource >= (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))) { _montagePos.chunkIdx++; _montagePos.frameIdx = 0; return; }

    // render the actual frame in the chunk (do not let selection preview overwrite it every tick)
    const bytes = _decodeFrameFromProject(ch._project, frameInSource);
    const chunkInfo = {
      name: ch.name,
      alias: ch.alias,
      frameIdx: frameInSource,
      totalFrames: (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))
    };
    renderPreviewFrameBytes(bytes, chunkInfo);

    // only update the selected chunk when we actually moved to a new chunk
    if(lastChunkIdx !== _montagePos.chunkIdx){
      // update selection highlight but do not force a chunk-start preview render
      selectMontageChunk(_montagePos.chunkIdx, false);
      lastChunkIdx = _montagePos.chunkIdx;
    }

      // update playback position UI (global frame index)
    const totalMontage = computeMontageTotalFrames();
    let before = 0;
    for(let i=0;i<_montagePos.chunkIdx;i++){
      const c = montageChunks[i];
      before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0;
    }
    const pos = before + _montagePos.frameIdx + 1;
    if(playPosEl) playPosEl.textContent = `${pos} / ${totalMontage}f`;
    // sync montageScrubber if present
    if(montageScrubber && currentMode === 'montage'){
      montageScrubber.max = String(totalMontage);
      montageScrubber.value = String(pos);
    }

    // update montage scrubber so progress moves during montage playback
    if(montageScrubber && currentMode === 'montage'){
      montageScrubber.max = String(totalMontage);
      montageScrubber.value = String(pos);
    }

    // advance
    _montagePos.frameIdx++;
    if(_montagePos.frameIdx >= total){ _montagePos.chunkIdx++; _montagePos.frameIdx = 0; }
    updateMontageMetaUI();
  }, Math.round(1000 / FPS));
}

function stopMontagePlayback(){
  montagePlaying = false; montagePlayBtn.textContent = 'Play';
  if(_montageTimer){ clearInterval(_montageTimer); _montageTimer = null; }
  // Keep current position when paused - don't reset
  const playPosEl = document.getElementById('montagePlayPos'); 
  const totalMontage = computeMontageTotalFrames();
  let before = 0;
  for(let i = 0; i < Math.min(_montagePos.chunkIdx, montageChunks.length); i++){
    const c = montageChunks[i];
    before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0;
  }
  const pos = before + (_montagePos.frameIdx || 0) + 1;
  if(playPosEl) playPosEl.textContent = `${pos} / ${totalMontage}f`;
  // sync montage scrubber to current position and visibility
  if(currentMode === 'montage'){
    const totalMontage = Math.max(1, computeMontageTotalFrames());
    if(montageScrubber){
      montageScrubber.step = '1';
      montageScrubber.max = String(totalMontage);
      let before = 0;
      for(let i = 0; i < Math.min(_montagePos.chunkIdx, montageChunks.length); i++){
        const c = montageChunks[i];
        before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0;
      }
      montageScrubber.value = String(Math.min(before + (_montagePos.frameIdx || 0) + 1, totalMontage));
      montageScrubber.style.display = '';
    }
  }else{
    if(montageScrubber) montageScrubber.style.display = 'none';
  }
  notify('Montage paused');
}

montagePlayBtn.addEventListener('click', ()=>{
  if(montagePlaying) stopMontagePlayback(); else startMontagePlayback();
});

// -------------------- Init --------------------
// Initializes a default 12-frame blank project. Modify this to change default
// startup state (e.g., load a sample file or change initial frame count).

function init(){
  frames = Array.from({length: 12}, ()=>makeBlankFrame());
  ensureStacks(frames.length);

  setTool('pencil');
  brushSizeLabel.textContent = brushSize.value;
  grayLabel.textContent = graySlider.value;
  onionLabel.textContent = onionSlider.value;

  initThumbs(false);
  renderMain();
  updateUI();

  // initial montage UI state
  selectMontageChunk(-1);

  // set initial button visibility (chunk mode by default)
  if(playBtn) playBtn.style.display = '';
  if(montagePlayBtn) montagePlayBtn.style.display = 'none';

  window.addEventListener('resize', ()=>renderMain());
}

init();

})();
</script>
</body>
</html>
