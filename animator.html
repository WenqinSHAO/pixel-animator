<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Frame-by-Frame Animator</title>
<style>
:root{--bg:#0b0f17;--panel:#121a27;--panel2:#0f1522;--text:#e6eefc;--muted:#9fb0cf;--accent:#5aa2ff;--danger:#ff5a7a;--border:#26344f}
*{box-sizing:border-box}
body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--text);background:linear-gradient(180deg,#081019,#070b12 55%,#05070c)}
header{padding:14px 18px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;gap:12px}
header h1{font-size:14px;margin:0;letter-spacing:.3px;color:var(--text);font-weight:600}
header .hint{font-size:12px;color:var(--muted)}
.wrap{display:grid;grid-template-columns:1fr 320px;gap:14px;padding:14px;max-width:1200px;margin:0 auto}
.card{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--border);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
.stage{padding:12px;display:flex;flex-direction:column;gap:12px}
.canvasPanel{display:flex;flex-direction:column;gap:10px}
.mainCanvasWrap{background:#060a12;border:1px solid var(--border);border-radius:12px;padding:10px;display:flex;justify-content:center;align-items:center}
canvas#main{width:512px;height:512px;border-radius:10px;border:1px solid rgba(255,255,255,.06);background:#fff;image-rendering:pixelated;touch-action:none;cursor:crosshair}

.toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
.group{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

button{appearance:none;border:1px solid var(--border);background:rgba(255,255,255,.03);color:var(--text);padding:8px 10px;border-radius:10px;font-size:12px;font-weight:600;letter-spacing:.2px;cursor:pointer;user-select:none}
button:hover{border-color:#35507c}
button.primary{border-color:rgba(90,162,255,.6);background:rgba(90,162,255,.12)}
button.danger{border-color:rgba(255,90,122,.65);background:rgba(255,90,122,.10)}
button:disabled{opacity:.55;cursor:not-allowed}

.pill{font-size:12px;color:var(--muted);padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:rgba(255,255,255,.02);display:inline-flex;gap:8px;align-items:center}
label{font-size:12px;color:var(--muted);display:flex;gap:8px;align-items:center}
input[type="range"]{width:160px}

.panelBlock{
  border:1px solid var(--border);
  border-radius:12px;
  background:rgba(0,0,0,.18);
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.panelHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.panelTitle{
  font-size:11px;
  color:var(--muted);
  letter-spacing:.35px;
  text-transform:uppercase;
}

.sidebar{padding:12px;display:flex;flex-direction:column;height:calc(100vh - 180px);overflow-y:auto}
.sidebar h2{display:none}
.sidebar .section{padding:10px;border:1px solid var(--border);border-radius:12px;background:rgba(0,0,0,.18);margin-bottom:12px;flex-shrink:0}
.sidebar .section:first-of-type{flex-shrink:1;display:flex;flex-direction:column;min-height:0}
.sidebar .section:first-of-type::before{content:'Frames';display:block;font-size:11px;color:var(--muted);letter-spacing:.35px;text-transform:uppercase;margin:0 0 10px;flex-shrink:0}
.sidebar .row{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:8px 0;flex-wrap:wrap}
.sidebar small{color:var(--muted)}
.frames{display:grid;grid-template-columns:repeat(6,1fr);gap:10px}
.framesWrap{flex:1;overflow:auto;padding-right:4px;min-height:0}
.thumb{border:1px solid var(--border);background:#060a12;border-radius:12px;padding:6px;cursor:pointer;position:relative}
.thumb.active{outline:2px solid rgba(90,162,255,.8);border-color:rgba(90,162,255,.65)}
.thumb.dragging{opacity:0.45}
.thumb.drag-over{outline:2px dashed rgba(90,162,255,.8);border-color:rgba(90,162,255,.65)}
.thumb canvas{width:100%;aspect-ratio:1/1;border-radius:8px;background:#fff;image-rendering:pixelated;border:1px solid rgba(255,255,255,.06)}
.thumb .idx{position:absolute;top:6px;left:8px;font-size:11px;padding:2px 6px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);color:#fff}

.frameOpsRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-top:10px}
.frameOpsRow .group{gap:8px}

/* Controls placed inside the Frames block: play, frame indicator, and scrubber */
.frameControls{display:flex;align-items:center;gap:10px;justify-content:space-between;margin-bottom:8px}
.frameControls .group{gap:8px}
.frameControls .scrubber{width:100%;height:28px}

.footerHint{color:var(--muted);font-size:12px;padding:6px 2px 0}

/* Toast notifications */
.toasts{position:fixed;right:18px;bottom:18px;display:flex;flex-direction:column;gap:8px;z-index:9999;padding:0;pointer-events:none}
.toast{pointer-events:auto;min-width:180px;max-width:360px;padding:10px 12px;border-radius:10px;background:linear-gradient(180deg,#0f1720,#0b131e);border:1px solid rgba(255,255,255,.06);color:var(--text);box-shadow:0 10px 30px rgba(0,0,0,.35);opacity:0;transform:translateY(6px);transition:opacity .18s ease,transform .18s ease}
.toast.visible{opacity:1;transform:translateY(0)}

@media (max-width:980px){
  .wrap{grid-template-columns:1fr}
  canvas#main{width:min(92vw,512px);height:min(92vw,512px)}
  .frames{grid-template-columns:repeat(4,1fr)}
}

/* Montage sidebar styles */
#montageSidebar .section{padding:10px}
#montageChunks{max-height:300px;overflow-y:auto}
#montageChunks .chunk-item{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;border:1px solid var(--border);background:rgba(255,255,255,.02)}
#montageChunks .chunk-item.active{outline:2px solid rgba(90,162,255,.8);border-color:rgba(90,162,255,.65);background:linear-gradient(180deg,rgba(90,162,255,.02),rgba(255,255,255,.01))}
#montageChunks .chunk-meta{font-size:12px;color:var(--muted);}
#montageChunks .chunk-controls{display:flex;gap:6px}

/* Trim bar */
#trimBarCanvas{position:relative}
.trim-handle{position:absolute;top:0;height:100%;width:10px;background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(0,0,0,.08));cursor:ew-resize;border-left:1px solid rgba(0,0,0,.18);border-right:1px solid rgba(255,255,255,.06);}
.trim-selection{position:absolute;top:0;height:100%;background:linear-gradient(90deg, rgba(90,162,255,.12), rgba(90,162,255,.06));pointer-events:none}
#trimBar .panelTitle{font-size:11px;color:var(--muted);letter-spacing:.35px;text-transform:uppercase}

/* Compact icon buttons used in montage chunk controls */
.iconBtn{padding:4px 6px;font-size:12px;border-radius:8px;min-width:30px}
.iconBtn.danger{border-color:rgba(255,90,122,.65);background:rgba(255,90,122,.06)}


</style>
</head>
<body>
<header>
  <h1 id="title">Frame-by-Frame Animator</h1>
  <div class="hint">
    Space play/pause · [ / ] or ←/→ prev/next · A add frame · D duplicate · Del delete frame · Ctrl/Cmd+Z undo · Ctrl/Cmd+Y redo · S save · G GIF · L load · N new
  </div>
  <div id="editorToggle" style="display:flex;gap:8px;align-items:center">
    <button id="toggleChunk" class="primary">Chunk Editor</button>
    <button id="toggleMontage">Montage Editor</button>
  </div>
</header>

<main class="wrap">
  <section class="card stage">
    <div class="canvasPanel">

      <!-- Drawing Ops -->
      <div id="drawingPanel" class="panelBlock">
        <div class="panelHeader">
          <div class="panelTitle">Drawing</div>
        </div>
        <div class="toolbar">
          <div class="group">
            <button id="toolPencil" class="primary">Pencil</button>
            <button id="toolEraser">Eraser</button>
            <button id="toolSoft">Soft</button>
            <button id="undoBtn">Undo</button>
            <button id="redoBtn">Redo</button>
          </div>
          <div class="group">
            <label>Brush
              <input id="brushSize" type="range" min="1" max="8" value="1"/>
              <span id="brushSizeLabel" class="pill">1</span>
            </label>
          </div>
        </div>
        <div class="toolbar">
          <div class="group">
            <label>Gray
              <input id="gray" type="range" min="0" max="255" value="0"/>
              <span id="grayLabel" class="pill">0</span>
            </label>
          </div>
          <div class="group">
            <label>Onion
              <input id="onion" type="range" min="0" max="8" value="5"/>
              <span id="onionLabel" class="pill">5</span>
            </label>
          </div>
        </div>
      </div>

      <div class="mainCanvasWrap">
        <canvas id="main" width="512" height="512" role="img" aria-label="Drawing canvas (128×128 grayscale)" tabindex="0"></canvas>
      </div>

      <!-- Trim bar for montage chunk trimming (always visible; disabled until a chunk is selected) -->
      <div id="trimBar" style="margin-top:10px;">
        <div class="panelBlock">
          <div class="panelHeader"><div class="panelTitle">Trim selected chunk</div></div>
          <div id="trimBarCanvas" style="position:relative;height:40px;margin-top:8px;border-radius:8px;background:linear-gradient(90deg, rgba(255,255,255,.02), rgba(255,255,255,.01));border:1px solid var(--border);overflow:hidden">
            <!-- handles will be added dynamically -->
          </div>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap">
            <div style="font-size:12px;color:var(--muted)">Range:</div>
            <label style="font-size:12px;color:var(--muted)">Start <input id="trimStartInput" type="number" style="width:70px"/></label>
            <label style="font-size:12px;color:var(--muted)">End <input id="trimEndInput" type="number" style="width:70px"/></label>
            <button id="trimApplyBtn">Apply</button>
            <button id="trimResetBtn">Reset</button>
          </div>
        </div>
      </div>

      <!-- Unified Scrubber (used in both chunk and montage modes) -->
      <div class="frameControls" style="margin-top:6px;">
        <button id="playBtn" class="primary">Play</button>
        <button id="montagePlayBtn" class="primary">Play</button>
        <div style="flex:1;">
          <input id="montageScrubber" class="scrubber" type="range" min="1" max="1" value="1" />
        </div>
      </div>



    </div>
  </section>

  <aside class="card sidebar">
    <h2>Frames</h2>

    <!-- Frames + Frame Ops -->
    <div class="section">

      <div class="frameControls">
        <span class="pill">Frame <span id="frameLabel">1</span> / <span id="frameTotal">12</span></span>
      </div>

      <div class="framesWrap">
        <div class="frames" id="frameGrid"></div>
      </div>

      <div class="frameOpsRow">
        <div class="group">
          <button id="addFrameBtn">Add</button>
          <button id="dupFrameBtn">Duplicate</button>
          <button id="delFrameBtn" class="danger">Delete</button>
        </div>
        <div class="group">
          <span class="pill">Selected: <span id="selectedFramePill">1</span></span>
        </div>
      </div>

      <div style="margin-top:10px;color:var(--muted);font-size:12px">Click thumbnail to edit — drag to reorder frames.</div>
    </div>

    <!-- Meta -->
    <div class="section">
      <div class="row"><small>Project</small><span id="lengthPill" class="pill">1.00 sec</span></div>
      <div class="row"><small>FPS</small><span class="pill">12</span></div>
      <div class="row"><small>Frames</small><span id="framesPill" class="pill">12</span></div>
      <div class="row"><small>Canvas</small><span class="pill">128×128</span></div>

      <div style="color:var(--muted);font-size:12px;margin-top:6px">Length updates automatically as you add/delete frames.</div>
    </div>

    <!-- Project Actions -->
    <div class="section">
      <div class="panelHeader">
        <div class="panelTitle">Project Actions</div>
      </div>
      <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
        <button id="saveProjectBtn">Save Project</button>
        <button id="loadProjectBtn">Load Project</button>
        <button id="saveBtn">Save GIF</button>
        <button id="newBtn" class="danger">New</button>
      </div>
      <div class="footerHint" style="margin-top:8px">Save Project is lossless JSON. Save GIF exports 512×512 with a white background.</div>
    </div>
  </aside>

  <!-- Montage Sidebar (hidden by default) -->
  <aside id="montageSidebar" class="card sidebar" style="display:none">
    <h2>Montage</h2>

    <div class="section">
      <div style="margin-top:10px" class="row"><small>Total frames</small><span id="montageTotalFrames" class="pill">0</span></div>
      <div style="margin-top:6px" class="row"><small>Playback</small><span id="montagePlayPos" class="pill">0 / 0f</span></div>
      <div style="margin-top:6px;color:var(--muted);font-size:12px">Import multiple JSON projects; trim (time-based) and reorder to compose a film.</div>
    </div>

    <div class="section" style="padding-top:8px">
      <div class="panelHeader"><div class="panelTitle">Chunks</div></div>
      <div id="montageChunks" style="display:flex;flex-direction:column;gap:8px;margin-top:8px"></div>
    </div>

    <div class="section" style="margin-top:10px">
      <div style="color:var(--muted);font-size:12px">Double-click a chunk to trim (frame range). Use Move Up/Down to reorder (drag-drop later).</div>
    </div>

    <!-- Import/Save at bottom -->
    <div class="section" style="margin-top:auto">
      <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
        <button id="montageImportBtn" title="Import multiple JSON projects to compose a film">Import</button>
        <span style="color:var(--border)">|</span>
        <button id="saveMontageBtn" title="Save montage as JSON with optional embedded projects">Save</button>
        <label style="display:inline-flex;align-items:center;gap:6px;font-size:12px;color:var(--muted)" title="Include all project data in saved file (otherwise only frame references)"><input id="montageEmbedCheckbox" type="checkbox"/> Self-contained</label>
      </div>
    </div>
  </aside>
</main>

<input id="loadProjectInput" type="file" accept=".json" style="display:none"/>

<input id="montageImportInput" type="file" accept=".json" multiple style="display:none"/>

<!-- Toast container for non-blocking notifications -->
<div id="toastContainer" aria-live="polite" aria-atomic="true" class="toasts"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
<script>
// validateProject - inline validation function
function validateProject(project, opts = {}){
  const errors = [];
  if(!project || typeof project !== 'object'){
    errors.push('Invalid project object');
    return { ok: false, errors };
  }

  if(!Array.isArray(project.frames)){
    errors.push('missing frames array');
    return { ok: false, errors };
  }

  const width = Number(project.width);
  const height = Number(project.height);
  if(!Number.isFinite(width) || !Number.isFinite(height)){
    errors.push('invalid width/height');
  }

  if(typeof opts.width !== 'undefined' && Number(opts.width) !== width){
    errors.push(`width mismatch (${width} != ${opts.width})`);
  }
  if(typeof opts.height !== 'undefined' && Number(opts.height) !== height){
    errors.push(`height mismatch (${height} != ${opts.height})`);
  }
  if(typeof opts.fps !== 'undefined' && typeof project.fps !== 'undefined' && Number(project.fps) !== Number(opts.fps)){
    errors.push(`fps mismatch (${project.fps} != ${opts.fps})`);
  }

  const frameCount = Number(project.frameCount || project.frames.length || 0);
  if(frameCount !== project.frames.length){
    errors.push(`frameCount (${frameCount}) does not match frames.length (${project.frames.length})`);
  }

  const expectedLen = (Number.isFinite(width) && Number.isFinite(height)) ? (width * height) : null;
  if(expectedLen !== null){
    for(let i = 0; i < project.frames.length; i++){
      const b64 = project.frames[i];
      if(typeof b64 !== 'string'){
        errors.push(`frame ${i} not a string`);
        break;
      }
      try{
        const bin = atob(b64);
        if(bin.length !== expectedLen){ errors.push(`frame ${i} length ${bin.length} != ${expectedLen}`); break; }
      }catch(e){
        errors.push(`frame ${i} invalid base64`);
        break;
      }
    }
  }

  return { ok: errors.length === 0, errors };
}

(()=>{

// Fixed raster + fixed FPS
// CONFIG: change these to adjust internal raster, exported display size, and playback rate:
//  - W, H: internal frame resolution (frames stored as W*H bytes).
//  - DISPLAY: visible canvas / GIF export resolution (can be larger than W to upscale).
//  - FPS: playback and GIF framerate (used for playback interval and GIF frame delay).
const W = 128, H = 128;
const DISPLAY = 512;
const FPS = 12;

const MAX_FRAMES = 600;
const UNDO_LIMIT = 100;

// Frames + history (dynamic length)
// NOTE: `frames` holds Uint8Array instances (W*H bytes each) representing grayscale pixels
// (0 = black, 255 = white). `undoStacks` / `redoStacks` are per-frame arrays of stroke deltas.
let frames = [];
let undoStacks = [];
let redoStacks = [];

// State
let current = 0;
let isPlaying = false;
let tool = 'pencil';
let brush = 1;
let gray = 0;
let onionDepth = 5;
let drawing = false;
let lastPt = null;

// Active stroke diff recording
let activeStrokeMap = null;

// DOM
const main = document.getElementById('main');
const ctx = main.getContext('2d', { alpha:false, willReadFrequently:true });
ctx.imageSmoothingEnabled = false;

const frameLabel = document.getElementById('frameLabel');
const frameTotalEl = document.getElementById('frameTotal');
const selectedFramePill = document.getElementById('selectedFramePill');

const playBtn = document.getElementById('playBtn');
const saveProjectBtn = document.getElementById('saveProjectBtn');
const loadProjectBtn = document.getElementById('loadProjectBtn');
const loadProjectInput = document.getElementById('loadProjectInput');

const saveBtn = document.getElementById('saveBtn');
const newBtn = document.getElementById('newBtn');

const addFrameBtn = document.getElementById('addFrameBtn');
const dupFrameBtn = document.getElementById('dupFrameBtn');
const delFrameBtn = document.getElementById('delFrameBtn');

const toolPencil = document.getElementById('toolPencil');
const toolEraser = document.getElementById('toolEraser');
const toolSoft = document.getElementById('toolSoft');

const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');

const brushSize = document.getElementById('brushSize');
const brushSizeLabel = document.getElementById('brushSizeLabel');

const graySlider = document.getElementById('gray');
const grayLabel = document.getElementById('grayLabel');

const onionSlider = document.getElementById('onion');
const onionLabel = document.getElementById('onionLabel');

const frameGrid = document.getElementById('frameGrid');
const lengthPill = document.getElementById('lengthPill');
const framesPill = document.getElementById('framesPill');
const montageScrubber = document.getElementById('montageScrubber');

// Offscreen for 128x128 composition
const off = document.createElement('canvas');
off.width = W; off.height = H;
const offCtx = off.getContext('2d', { willReadFrequently:true });
offCtx.imageSmoothingEnabled = false;

// Thumbnails
const thumbs = [];
const thumbCanvases = [];

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function roundTo(n, decimals=2){
  const p = Math.pow(10, decimals);
  return Math.round(n*p)/p;
}

function makeBlankFrame(){
  // Creates a blank grayscale frame as a byte array (1 byte per pixel).
  // To switch to color or RGBA frames, replace this with a Uint8ClampedArray(W*H*4)
  // and update compose/draw functions accordingly.
  const a = new Uint8Array(W*H);
  a.fill(255);
  return a;
}

function ensureStacks(count){
  while(undoStacks.length < count) undoStacks.push([]);
  while(redoStacks.length < count) redoStacks.push([]);
  if(undoStacks.length > count) undoStacks.length = count;
  if(redoStacks.length > count) redoStacks.length = count;
}

function updateProjectMetaUI(){
  const count = frames.length;
  frameTotalEl.textContent = String(count);
  framesPill.textContent = String(count);
  lengthPill.textContent = `${roundTo(count / FPS, 2)} sec`;
  selectedFramePill.textContent = String(current + 1);

  // scrubber sync (if present) — use `montageScrubber` as the single control
  if(montageScrubber){
    montageScrubber.step = '1';
    if(currentMode === 'montage'){
      const totalMontage = Math.max(1, computeMontageTotalFrames());
      montageScrubber.max = String(totalMontage);
      let before = 0; for(let i=0;i<Math.min(_montagePos.chunkIdx, montageChunks.length);i++){ const c = montageChunks[i]; before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0; }
      const pos = Math.max(1, (before + (_montagePos.frameIdx || 0) + 1));
      montageScrubber.value = String(Math.min(pos, totalMontage));
      montageScrubber.style.display = '';
    }else{
      montageScrubber.max = String(count);
      montageScrubber.value = String(current + 1);
      montageScrubber.style.display = '';
    }
  }
}

function updateUI(){
  frameLabel.textContent = String(current + 1);
  selectedFramePill.textContent = String(current + 1);
  updateProjectMetaUI();
  updateUndoRedoButtons();
}

function setTool(next){
  tool = next;
  toolPencil.classList.toggle('primary', tool === 'pencil');
  toolEraser.classList.toggle('primary', tool === 'eraser');
  toolSoft.classList.toggle('primary', tool === 'soft');
  // Reflect state for assistive technologies
  try{
    toolPencil.setAttribute('aria-pressed', String(tool === 'pencil'));
    toolEraser.setAttribute('aria-pressed', String(tool === 'eraser'));
    toolSoft.setAttribute('aria-pressed', String(tool === 'soft'));
  }catch(_){ }
}

function setCurrent(idx){
  current = clamp(idx, 0, frames.length - 1);
  thumbs.forEach((el,i)=>el.classList.toggle('active', i === current));
  updateUI();
  renderMain();
}

function xyToIndex(x,y){ return y*W + x; }

function getPointerXY(ev){
  const rect = main.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * (W / rect.width);
  const y = (ev.clientY - rect.top) * (H / rect.height);
  return {
    x: clamp(Math.floor(x), 0, W - 1),
    y: clamp(Math.floor(y), 0, H - 1)
  };
}

// Fixed brush: size s draws s×s square (even sizes included)
// Brush implementation is intentionally simple (square). To make a round brush:
// - replace this with a circular mask (distance check from center)
// - or implement alpha blending for softer strokes.
function drawDot(frameArr, x, y, value, size){
  const s = Math.max(1, size|0);
  const start = -Math.floor(s/2);
  const end = start + s - 1;
  for(let dy = start; dy <= end; dy++){
    for(let dx = start; dx <= end; dx++){
      const xx = x + dx, yy = y + dy;
      if(xx < 0 || yy < 0 || xx >= W || yy >= H) continue;
      const idx = xyToIndex(xx, yy);

      if(activeStrokeMap && !activeStrokeMap.has(idx)){
        activeStrokeMap.set(idx, frameArr[idx]);
      }
      frameArr[idx] = value;
    }
  }
}

function drawLine(frameArr, x0, y0, x1, y1, value, size){
  let dx = Math.abs(x1-x0);
  let sx = x0 < x1 ? 1 : -1;
  let dy = -Math.abs(y1-y0);
  let sy = y0 < y1 ? 1 : -1;
  let err = dx + dy;
  while(true){
    drawDot(frameArr, x0, y0, value, size);
    if(x0 === x1 && y0 === y1) break;
    const e2 = 2 * err;
    if(e2 >= dy){ err += dy; x0 += sx; }
    if(e2 <= dx){ err += dx; y0 += sy; }
  }
}

// Soft (blended) brush: blends the target value into existing pixels with a radial falloff
// to produce smoother, less pixelated edges. Deltas are recorded in `activeStrokeMap`
// so undo/redo continues to work as expected.
function drawSoftDot(frameArr, x, y, value, size){
  const s = Math.max(1, size|0);
  const start = -Math.floor(s/2);
  const end = start + s - 1;
  const radius = Math.max(0.5, s / 2);

  for(let dy = start; dy <= end; dy++){
    for(let dx = start; dx <= end; dx++){
      const xx = x + dx, yy = y + dy;
      if(xx < 0 || yy < 0 || xx >= W || yy >= H) continue;
      const idx = xyToIndex(xx, yy);
      const dist = Math.hypot(dx, dy);
      let alpha = 1 - (dist / radius);
      if(radius === 0) alpha = 1;
      alpha = clamp(alpha, 0, 1);
      // Slight gamma to soften edges
      alpha = Math.pow(alpha, 1.2);

      const prev = frameArr[idx];
      const blended = Math.round(prev * (1 - alpha) + value * alpha);
      if(activeStrokeMap && !activeStrokeMap.has(idx)){
        activeStrokeMap.set(idx, prev);
      }
      frameArr[idx] = blended;
    }
  }
}

function drawLineSoft(frameArr, x0, y0, x1, y1, value, size){
  let dx = Math.abs(x1-x0);
  let sx = x0 < x1 ? 1 : -1;
  let dy = -Math.abs(y1-y0);
  let sy = y0 < y1 ? 1 : -1;
  let err = dx + dy;
  while(true){
    drawSoftDot(frameArr, x0, y0, value, size);
    if(x0 === x1 && y0 === y1) break;
    const e2 = 2 * err;
    if(e2 >= dy){ err += dy; x0 += sx; }
    if(e2 <= dx){ err += dx; y0 += sy; }
  }
}

// Onion skin unchanged
function ghostGrayForDistance(d){ return clamp(110 + (d-1)*30, 110, 235); }

function composeWithOnionSkin(frameIndex, depth){
  const out = new Uint8ClampedArray(W*H*4);
  const base = new Uint8Array(W*H);
  base.fill(255);

  for(let d=1; d<=depth; d++){
    const idx = frameIndex - d;
    if(idx < 0) break;
    const g = ghostGrayForDistance(d);
    const src = frames[idx];
    for(let p=0; p<src.length; p++){
      if(src[p] < 250){
        if(g < base[p]) base[p] = g;
      }
    }
  }

  const cur = frames[frameIndex];
  for(let p=0; p<cur.length; p++){
    if(cur[p] < base[p]) base[p] = cur[p];
  }

  for(let p=0,o=0; p<base.length; p++,o+=4){
    const v = base[p];
    out[o]=v; out[o+1]=v; out[o+2]=v; out[o+3]=255;
  }
  return new ImageData(out, W, H);
}

function composeFrameOnly(frameIndex){
  const out = new Uint8ClampedArray(W*H*4);
  const src = frames[frameIndex];
  for(let p=0,o=0; p<src.length; p++,o+=4){
    const v = src[p];
    out[o]=v; out[o+1]=v; out[o+2]=v; out[o+3]=255;
  }
  return new ImageData(out, W, H);
}

function renderMain(){
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const target = DISPLAY * dpr;
  if(main.width !== target || main.height !== target){
    main.width = target;
    main.height = target;
    ctx.imageSmoothingEnabled = false;
  }

  offCtx.putImageData(isPlaying ? composeFrameOnly(current) : composeWithOnionSkin(current, onionDepth), 0, 0);
  ctx.clearRect(0, 0, main.width, main.height);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(off, 0, 0, main.width, main.height);
}

function renderThumb(i){
  const c = thumbCanvases[i];
  const tctx = c.getContext('2d', { alpha:false });
  tctx.imageSmoothingEnabled = false;

  offCtx.putImageData(composeFrameOnly(i), 0, 0);
  tctx.clearRect(0, 0, c.width, c.height);
  tctx.drawImage(off, 0, 0, c.width, c.height);
}

function renderAllThumbs(){
  for(let i=0; i<frames.length; i++) renderThumb(i);
}

// Simple non-blocking toast notifications (falls back to alert)
function showToast(msg, {timeout=3000}={}){
  const container = document.getElementById('toastContainer');
  if(!container){ alert(msg); return; }
  const el = document.createElement('div');
  el.className = 'toast';
  el.textContent = msg;
  container.appendChild(el);
  // trigger visible state
  requestAnimationFrame(()=> el.classList.add('visible'));
  setTimeout(()=>{ el.classList.remove('visible'); setTimeout(()=> el.remove(), 200); }, timeout);
}

function notify(msg){ showToast(msg); }

// -------------------- Undo / Redo --------------------
// Per-frame undo/redo stacks store delta objects `{idxs, before, after}` produced by
// `commitStroke()`. This keeps memory bounded and allows frame-level undo without
// copying entire frames.

function updateUndoRedoButtons(){
  const canU = !isPlaying && undoStacks[current] && undoStacks[current].length > 0;
  const canR = !isPlaying && redoStacks[current] && redoStacks[current].length > 0;
  undoBtn.disabled = !canU;
  redoBtn.disabled = !canR;
}

function beginStroke(){ activeStrokeMap = new Map(); }

function commitStroke(){
  if(!activeStrokeMap) return;
  if(activeStrokeMap.size === 0){
    activeStrokeMap = null;
    return;
  }

  const idxs = new Uint32Array(activeStrokeMap.size);
  const before = new Uint8Array(activeStrokeMap.size);
  const after = new Uint8Array(activeStrokeMap.size);

  let k = 0;
  const frameArr = frames[current];
  for(const [idx, prev] of activeStrokeMap.entries()){
    idxs[k] = idx;
    before[k] = prev;
    after[k] = frameArr[idx];
    k++;
  }

  undoStacks[current].push({ idxs, before, after });
  if(undoStacks[current].length > UNDO_LIMIT) undoStacks[current].shift();

  redoStacks[current].length = 0;

  activeStrokeMap = null;
  updateUndoRedoButtons();
}

function applyDelta(frameIdx, idxs, values){
  const arr = frames[frameIdx];
  for(let i=0; i<idxs.length; i++){
    arr[idxs[i]] = values[i];
  }
}

function undo(){
  if(isPlaying) return;
  const stack = undoStacks[current];
  if(!stack || stack.length === 0) return;

  const delta = stack.pop();
  applyDelta(current, delta.idxs, delta.before);
  redoStacks[current].push(delta);

  renderMain();
  renderThumb(current);
  updateUndoRedoButtons();
}

function redo(){
  if(isPlaying) return;
  const stack = redoStacks[current];
  if(!stack || stack.length === 0) return;

  const delta = stack.pop();
  applyDelta(current, delta.idxs, delta.after);
  undoStacks[current].push(delta);
  if(undoStacks[current].length > UNDO_LIMIT) undoStacks[current].shift();

  renderMain();
  renderThumb(current);
  updateUndoRedoButtons();
}

// -------------------- Timeline operations (Add / Duplicate / Delete) --------------------

function insertFrame(afterIndex, sourceFrameOrNull){
  if(isPlaying) return;
  if(frames.length >= MAX_FRAMES){
    notify(`Max frames reached (${MAX_FRAMES}).`);
    return;
  }

  const insertAt = clamp(afterIndex + 1, 0, frames.length);

  const newFrame = makeBlankFrame();
  if(sourceFrameOrNull instanceof Uint8Array){
    newFrame.set(sourceFrameOrNull);
  }

  frames.splice(insertAt, 0, newFrame);
  undoStacks.splice(insertAt, 0, []);
  redoStacks.splice(insertAt, 0, []);
  ensureStacks(frames.length);

  initThumbs(true);
  renderAllThumbs();
  setCurrent(insertAt);
  updateProjectMetaUI();
}

function addBlankAfterCurrent(){ insertFrame(current, null); }
function duplicateAfterCurrent(){ insertFrame(current, frames[current]); }

function deleteCurrentFrame(){
  if(isPlaying) return;
  if(frames.length <= 1){
    notify('Cannot delete the last remaining frame.');
    return;
  }

  const n = current + 1;
  const ok = confirm(`Delete frame ${n}? This cannot be undone.`);
  if(!ok) return;

  frames.splice(current, 1);
  undoStacks.splice(current, 1);
  redoStacks.splice(current, 1);
  ensureStacks(frames.length);

  // keep selection sensible
  current = clamp(current, 0, frames.length - 1);

  initThumbs(true);
  renderAllThumbs();
  renderMain();
  updateUI();
}

// Insert a frame from index `from` so it appears immediately BEFORE the frame at index `to` (drop target).
// `to` should be the index of the thumbnail dropped onto, or `frames.length` to append at the end.
// This updates frames and undo/redo stacks and keeps selection sensible.
function insertFrameBefore(from, to){
  if(isPlaying) return;
  // No-op for invalid indices or dropping onto itself
  if(from === to || from < 0 || to < 0) return;

  // Compute an insertion index in the array *after* we remove the source frame.
  // When moving forward (from < to), the target shifts left by 1 after removal,
  // so we want to insert at (to - 1). Otherwise insert at `to`.
  let insertAt = (from < to) ? (to - 1) : to;

  // Remove source frame and its history first
  const f = frames.splice(from, 1)[0];
  const u = undoStacks.splice(from, 1)[0];
  const r = redoStacks.splice(from, 1)[0];

  // After removal, clamp insertion position to valid bounds [0, frames.length]
  insertAt = clamp(insertAt, 0, frames.length);

  // Insert at computed position
  frames.splice(insertAt, 0, f);
  undoStacks.splice(insertAt, 0, u);
  redoStacks.splice(insertAt, 0, r);

  // Adjust current index to keep selection consistent
  if(current === from){
    current = insertAt;
  }else if(from < insertAt){
    if(current > from && current <= insertAt) current -= 1;
  }else{
    if(current >= insertAt && current < from) current += 1;
  }

  initThumbs(true);
  renderAllThumbs();
  renderMain();
  updateUI();
}

// -------------------- Project Save/Load (FPS fixed at 12) --------------------
// Projects store raw frame bytes base64-encoded. This keeps export/import tiny and
// fully lossless for the internal byte representation. To switch to PNG data URIs,
// change `saveProject()` to encode `off.toDataURL()` per-frame and update `loadProject()` accordingly.
function saveProject(){
  const project = {
    version: '1.3',
    width: W,
    height: H,
    fps: FPS,
    frameCount: frames.length,
    timestamp: new Date().toISOString(),
    frames: frames.map(f=>{
      let binary = '';
      for(let i=0;i<f.length;i++) binary += String.fromCharCode(f[i]);
      return btoa(binary);
    })
  };

  const json = JSON.stringify(project, null, 2);
  const blob = new Blob([json], { type:'application/json' });

  const a = document.createElement('a');
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  a.download = `animation-project-${ts}.json`;
  a.href = URL.createObjectURL(blob);

  document.body.appendChild(a);
  a.click();
  a.remove();

  setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
}

async function loadProject(file){
  const text = await file.text();
  let project;
  try{
    project = JSON.parse(text);
  }catch(e){
    notify(`Failed to parse project JSON: ${e.message}`);
    console.error('Failed to parse project', file.name, e);
    throw e;
  }

  if(!project || !project.frames || !Array.isArray(project.frames)){
    const msg = 'Invalid project file format: missing frames array';
    notify(msg);
    throw new Error(msg);
  }
  if(project.width !== W || project.height !== H){
    const msg = `Project dimensions (${project.width}×${project.height}) don't match canvas (${W}×${H})`;
    notify(msg);
    throw new Error(msg);
  }

  const nextCount = clamp(Number(project.frameCount || project.frames.length || 1), 1, MAX_FRAMES);

  // validate using shared validateProject helper so we keep logic consistent with scripts/validator
  try{
    if(typeof validateProject !== 'function') throw new Error('Validation function not available');
    const res = validateProject(project, { width: W, height: H, fps: FPS });
    if(!res.ok) throw new Error(res.errors.join('; '));
  }catch(e){
    notify(`Project validation failed: ${e.message}`);
    console.error('Project validation failed', file.name, e);
    throw e;
  }

  frames = Array.from({length: nextCount}, ()=>makeBlankFrame());
  undoStacks = [];
  redoStacks = [];
  ensureStacks(nextCount);

  for(let i=0; i<nextCount; i++){
    if(i < project.frames.length){
      const base64 = project.frames[i];
      const binary = atob(base64);
      const arr = new Uint8Array(binary.length);
      for(let j=0; j<binary.length; j++) arr[j] = binary.charCodeAt(j);
      frames[i].set(arr);
    }else{
      frames[i].fill(255);
    }
  }

  initThumbs(false);
  setCurrent(0);
  renderAllThumbs();
  renderMain();
  updateUI();
}

// -------------------- GIF Export (512×512, white background) --------------------
// Export composes each frame to a DISPLAY×DISPLAY canvas (white background) and feeds
// frames to `gif.js`. `getGifWorkerBlobUrl()` prefers `./vendor/gif.worker.js` and falls
// back to CDN; keep `vendor/gif.worker.js` in-project for offline builds.
// Worker loader: try local vendor/gif.worker.js first, then fallback to CDN. Returns a blob URL.
let _gifWorkerBlobUrl = null;
async function getGifWorkerBlobUrl(){
  if(_gifWorkerBlobUrl) return _gifWorkerBlobUrl;

  // Try both the expected worker filename and a previously observed misspelling in this repository
  const candidates = ['./vendor/gif.worker.js', './vendor/gif.woker.js', 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'];
  for(const url of candidates){
    try{
      const resp = await fetch(url);
      if(!resp.ok) continue;
      const text = await resp.text();
      const blob = new Blob([text], { type: 'application/javascript' });
      _gifWorkerBlobUrl = URL.createObjectURL(blob);
      console.info('Loaded gif.worker from', url);
      return _gifWorkerBlobUrl;
    }catch(err){
      console.warn('Failed to fetch worker from', url, err);
      continue;
    }
  }

  notify('Could not load gif.worker.js. Add ./vendor/gif.worker.js to your project or enable network access.');
  throw new Error('gif.worker.js not available');
}

function setExporting(state){
  const disable = Boolean(state);

  // Project buttons
  saveProjectBtn.disabled = disable;
  loadProjectBtn.disabled = disable;
  saveBtn.disabled = disable;
  newBtn.disabled = disable;

  // Frame buttons
  addFrameBtn.disabled = disable;
  dupFrameBtn.disabled = disable;
  delFrameBtn.disabled = disable;

  // Drawing controls
  toolPencil.disabled = disable;
  toolEraser.disabled = disable;
  brushSize.disabled = disable;
  graySlider.disabled = disable;
  onionSlider.disabled = disable;

  // Undo/redo
  undoBtn.disabled = disable;
  redoBtn.disabled = disable;

  // Playback
  playBtn.disabled = disable;

  // Scrubber (in Frames block)
  if(montageScrubber) montageScrubber.disabled = disable;

  // Provide simple feedback
  saveBtn.textContent = disable ? 'Exporting...' : 'Save GIF';
}

async function saveGif(){
  setExporting(true);
  try{
    const workerUrl = await getGifWorkerBlobUrl();

    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: DISPLAY,
      height: DISPLAY,
      repeat: 0,
      workerScript: workerUrl
    });

    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = DISPLAY;
    exportCanvas.height = DISPLAY;
    const ectx = exportCanvas.getContext('2d', { alpha:false });
    ectx.imageSmoothingEnabled = false;

    const delay = Math.round(1000 / FPS);

    for(let i=0; i<frames.length; i++){
      offCtx.putImageData(composeFrameOnly(i), 0, 0);

      ectx.setTransform(1,0,0,1,0,0);
      ectx.clearRect(0,0,DISPLAY,DISPLAY);
      ectx.fillStyle = '#ffffff';
      ectx.fillRect(0,0,DISPLAY,DISPLAY);

      ectx.imageSmoothingEnabled = false;
      ectx.drawImage(off, 0, 0, DISPLAY, DISPLAY);

      gif.addFrame(exportCanvas, { copy:true, delay });
    }

    await new Promise((resolve, reject)=>{
      gif.on('finished', blob => {
        const a = document.createElement('a');
        const ts = new Date().toISOString().replace(/[:.]/g,'-');
        a.download = `animation-${ts}.gif`;
        a.href = URL.createObjectURL(blob);
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1500);

        // revoke worker blob URL if we generated it
        if(workerUrl && workerUrl.startsWith('blob:')){
          try{ URL.revokeObjectURL(workerUrl); }catch(_){ }
          if(workerUrl === _gifWorkerBlobUrl) _gifWorkerBlobUrl = null;
        }

        setExporting(false);
        resolve();
      });

      gif.on('error', err => {
        console.error('GIF render error', err);
        notify(`Failed to render GIF: ${err && err.message ? err.message : String(err)}`);
        // revoke worker url on error
        if(workerUrl && workerUrl.startsWith('blob:')){
          try{ URL.revokeObjectURL(workerUrl); }catch(_){ }
          if(workerUrl === _gifWorkerBlobUrl) _gifWorkerBlobUrl = null;
        }
        setExporting(false);
        reject(err);
      });

      gif.render();
    });





  }catch(err){
    console.error('saveGif error', err);
    notify(`Failed to start GIF export: ${err && err.message ? err.message : String(err)}`);
    setExporting(false);
  }finally{
    setExporting(false);
  }
}



// -------------------- Playback --------------------

let playTimer = null;

function setPlaying(next){
  isPlaying = next;
  playBtn.textContent = isPlaying ? 'Stop' : 'Play';

  const disable = isPlaying;

  // Project buttons
  saveProjectBtn.disabled = disable;
  loadProjectBtn.disabled = disable;
  saveBtn.disabled = disable;
  newBtn.disabled = disable;

  // Frame buttons (now in sidebar)
  addFrameBtn.disabled = disable;
  dupFrameBtn.disabled = disable;
  delFrameBtn.disabled = disable;

  // Drawing controls
  toolPencil.disabled = disable;
  toolEraser.disabled = disable;
  brushSize.disabled = disable;
  graySlider.disabled = disable;
  onionSlider.disabled = disable;

  // Undo/redo
  if(disable){
    undoBtn.disabled = true;
    redoBtn.disabled = true;
  }else{
    updateUndoRedoButtons();
  }

  if(isPlaying){
    let idx = current;
    const interval = Math.round(1000 / FPS);
    playTimer = setInterval(()=>{
      current = idx;
      thumbs.forEach((el,i)=>el.classList.toggle('active', i === current));
      updateUI();
      renderMain();
      idx = (idx + 1) % frames.length;
    }, interval);
  }else{
    if(playTimer){
      clearInterval(playTimer);
      playTimer = null;
    }
    renderMain();
    updateUI();
  }
}

// -------------------- Thumbnails --------------------
// `initThumbs(preserveIndex)` builds the thumbnail grid. If `preserveIndex=false` the
// selection is reset to the first frame (useful after load/new).

function initThumbs(preserveIndex = true){
  const prev = current;

  frameGrid.innerHTML = '';
  thumbs.length = 0;
  thumbCanvases.length = 0;

  for(let i=0; i<frames.length; i++){
    const el = document.createElement('div');
    el.className = 'thumb';
    el.title = `Frame ${i+1}`;

    const idx = document.createElement('div');
    idx.className = 'idx';
    idx.textContent = String(i+1);

    const c = document.createElement('canvas');
    c.width = 64;
    c.height = 64;
    c.getContext('2d', { alpha:false }).imageSmoothingEnabled = false;

    el.appendChild(idx);
    el.appendChild(c);

    // Click selects frame
    el.addEventListener('click', ()=>{
      if(isPlaying) return;
      setCurrent(i);
    });

    // Make thumbnails draggable to support reordering
    el.draggable = true;

    el.addEventListener('dragstart', ev => {
      if(isPlaying){ ev.preventDefault(); return; }
      try{ ev.dataTransfer.setData('text/plain', String(i)); }catch(_){ }
      ev.dataTransfer.effectAllowed = 'move';
      el.classList.add('dragging');
    });

    el.addEventListener('dragover', ev => {
      ev.preventDefault();
      ev.dataTransfer.dropEffect = 'move';
      el.classList.add('drag-over');
    });

    el.addEventListener('dragleave', ev => {
      el.classList.remove('drag-over');
    });

    el.addEventListener('drop', ev => {
      ev.preventDefault();
      el.classList.remove('drag-over');
      const from = Number(ev.dataTransfer.getData('text/plain'));
      const to = thumbs.indexOf(el);
      if(Number.isNaN(from) || from === to) return;
      insertFrameBefore(from, to);
    });

    el.addEventListener('dragend', ev => {
      thumbs.forEach(t=>t.classList.remove('dragging','drag-over'));
    });

    frameGrid.appendChild(el);
    thumbs.push(el);
    thumbCanvases.push(c);
  }

  const next = preserveIndex ? clamp(prev, 0, frames.length - 1) : 0;
  setCurrent(next);
  renderAllThumbs();
  updateProjectMetaUI();
}

// Allow dropping on the grid background to move a frame to the end
frameGrid.addEventListener('dragover', ev => { ev.preventDefault(); ev.dataTransfer.dropEffect = 'move'; });
frameGrid.addEventListener('drop', ev => { ev.preventDefault(); const from = Number(ev.dataTransfer.getData('text/plain')); if(Number.isNaN(from)) return; insertFrameBefore(from, frames.length); });

// -------------------- Drawing --------------------
// Pointer events (pointerdown/pointermove/pointerup) call `applyStroke()` which
// records deltas via `beginStroke()` / `commitStroke()`. To add a new tool,
// handle it in `applyStroke()` and set state via `setTool()`.

function applyStroke(from, to){
  const frameArr = frames[current];
  const value = (tool === 'eraser') ? 255 : gray;

  if(tool === 'soft'){
    if(!from){
      drawSoftDot(frameArr, to.x, to.y, value, brush);
    }else{
      drawLineSoft(frameArr, from.x, from.y, to.x, to.y, value, brush);
    }
  }else{
    if(!from){
      drawDot(frameArr, to.x, to.y, value, brush);
    }else{
      drawLine(frameArr, from.x, from.y, to.x, to.y, value, brush);
    }
  }

  renderMain();
  renderThumb(current);
}

main.addEventListener('pointerdown', ev=>{
  if(isPlaying) return;
  if(currentMode !== 'chunk') return; // disable drawing in montage mode
  drawing = true;
  main.setPointerCapture(ev.pointerId);

  beginStroke();
  const pt = getPointerXY(ev);
  lastPt = pt;
  applyStroke(null, pt);
});

main.addEventListener('pointermove', ev=>{
  if(!drawing || isPlaying) return;
  if(currentMode !== 'chunk') return; // disable drawing in montage mode
  const pt = getPointerXY(ev);
  applyStroke(lastPt, pt);
  lastPt = pt;
});

function endDraw(ev){
  if(!drawing) return;
  drawing = false;
  lastPt = null;

  commitStroke();

  try{ main.releasePointerCapture(ev.pointerId); }catch(_){}
}

main.addEventListener('pointerup', endDraw);
main.addEventListener('pointercancel', endDraw);

// -------------------- UI events --------------------

toolPencil.addEventListener('click', ()=>setTool('pencil'));
toolEraser.addEventListener('click', ()=>setTool('eraser'));
toolSoft.addEventListener('click', ()=>setTool('soft'));

undoBtn.addEventListener('click', ()=>undo());
redoBtn.addEventListener('click', ()=>redo());

addFrameBtn.addEventListener('click', ()=>addBlankAfterCurrent());
dupFrameBtn.addEventListener('click', ()=>duplicateAfterCurrent());
delFrameBtn.addEventListener('click', ()=>deleteCurrentFrame());

playBtn.addEventListener('click', ()=>setPlaying(!isPlaying));

// Scrubber: using single montageScrubber for both chunk and montage modes
if(montageScrubber){
  montageScrubber.addEventListener('pointerdown', ()=>{
    if(isPlaying) setPlaying(false);
    if(montagePlaying) stopMontagePlayback();
  });
  montageScrubber.addEventListener('input', ()=>{
    // Unified scrubber handler for both chunk editor and montage modes
    // This is the single 'input' listener for montageScrubber - handles both:
    // 1. Chunk editor mode (currentMode !== 'montage'): calls setCurrent() to select frame
    // 2. Montage mode: interprets scrubber as global montage frame index and renders accordingly
    
    // always pause active playback modes when user scrubs
    if(isPlaying) setPlaying(false);
    if(montagePlaying) stopMontagePlayback();

    // Normal frame mode: select the frame and render it
    if(currentMode !== 'montage'){
      setCurrent(Number(montageScrubber.value) - 1);
      renderMain(); // Explicitly render to ensure canvas updates
      return;
    }

    // Montage mode: interpret scrubber as global montage frame index (1-based)
    const totalMontage = computeMontageTotalFrames();
    const pos = clamp(Number(montageScrubber.value), 1, Math.max(1, totalMontage));

    let acc = 0;
    let found = false;
    for(let i=0;i<montageChunks.length;i++){
      const ch = montageChunks[i];
      const len = (ch.frameRange && (ch.frameRange.end - ch.frameRange.start)) || 0;
      if(pos <= acc + len){
        const frameIdx = pos - acc - 1;
        // update internal playhead
        _montagePos.chunkIdx = i;
        _montagePos.frameIdx = frameIdx;
        // render the frame if project available
        if(ch._project){
          const frameInSource = ch.frameRange.start + frameIdx;
          if(frameInSource < (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))){
            const bytes = _decodeFrameFromProject(ch._project, frameInSource);
            renderPreviewFrameBytes(bytes);
          }
        }
        // update selection highlight without forcing the chunk-start preview render
        selectMontageChunk(i, false);
        const playPosEl = document.getElementById('montagePlayPos'); if(playPosEl) playPosEl.textContent = `${pos} / ${totalMontage}f`;
        found = true;
        break;
      }
      acc += len;
    }

    if(!found){
      const blank = new Uint8Array(W*H); blank.fill(240); renderPreviewFrameBytes(blank);
      const playPosEl = document.getElementById('montagePlayPos'); if(playPosEl) playPosEl.textContent = `0 / ${totalMontage}f`;
    }
  });
}

// Dedicated montage scrubber (per-frame across all chunks)
// Note: The 'input' event listener for montageScrubber is defined earlier (line ~1337)
// and handles both chunk editor mode and montage mode. The 'pointerdown' listener
// is kept here for consistency with other scrubber controls.
if(montageScrubber){
  montageScrubber.addEventListener('pointerdown', ()=>{
    if(isPlaying) setPlaying(false);
    if(montagePlaying) stopMontagePlayback();
  });
}


saveProjectBtn.addEventListener('click', ()=>{
  if(isPlaying) return;
  saveProject();
});

loadProjectBtn.addEventListener('click', ()=>{
  if(isPlaying) return;
  loadProjectInput.value = '';
  loadProjectInput.click();
});

loadProjectInput.addEventListener('change', async ()=>{
  if(isPlaying) return;
  const file = loadProjectInput.files && loadProjectInput.files[0];
  if(!file) return;
  try{
    await loadProject(file);
  }catch(err){
    console.error(err);
    notify(`Failed to load project: ${err && err.message ? err.message : String(err)}`);
  }
});

saveBtn.addEventListener('click', ()=>{
  if(isPlaying) return;
  saveGif();
});

newBtn.addEventListener('click', ()=>{
  if(isPlaying) return;

  // reset to 12 blank frames
  frames = Array.from({length: 12}, ()=>makeBlankFrame());
  undoStacks = [];
  redoStacks = [];
  ensureStacks(frames.length);

  current = 0;
  initThumbs(false);
  renderAllThumbs();
  renderMain();
  updateUI();
});

brushSize.addEventListener('input', ()=>{
  brush = Number(brushSize.value);
  brushSizeLabel.textContent = String(brush);
});

graySlider.addEventListener('input', ()=>{
  gray = Number(graySlider.value);
  grayLabel.textContent = String(gray);
});

onionSlider.addEventListener('input', ()=>{
  onionDepth = Number(onionSlider.value);
  onionLabel.textContent = String(onionDepth);
  if(!isPlaying) renderMain();
});

// Keyboard shortcuts
window.addEventListener('keydown', e=>{
  if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;

  // Undo/Redo
  const mod = e.ctrlKey || e.metaKey;
  if(mod && !isPlaying){
    const k = e.key.toLowerCase();
    if(k === 'z'){
      e.preventDefault();
      if(e.shiftKey) redo();
      else undo();
      return;
    }
    if(k === 'y'){
      e.preventDefault();
      redo();
      return;
    }
  }

  if(e.code === 'Space'){
    e.preventDefault();
    setPlaying(!isPlaying);
    return;
  }

  // Frame navigation
  if(!isPlaying){
    if(e.key === '[' || e.code === 'ArrowLeft'){
      e.preventDefault();
      setCurrent(current - 1);
      return;
    }
    if(e.key === ']' || e.code === 'ArrowRight'){
      e.preventDefault();
      setCurrent(current + 1);
      return;
    }
  }

  // Delete current frame
  if(!isPlaying && (e.code === 'Delete' || e.code === 'Backspace')){
    e.preventDefault();
    deleteCurrentFrame();
    return;
  }

  const k = e.key.toLowerCase();
  // Do not run single-letter shortcuts when any modifier key is pressed — this avoids colliding
  // with browser or OS shortcuts like Ctrl/Cmd+S, Ctrl/Cmd+G, etc.
  const hasModifier = e.ctrlKey || e.metaKey || e.altKey || e.shiftKey;
  if(!hasModifier){
    if(k === 's'){
      if(!isPlaying){ e.preventDefault(); saveProject(); }
    }else if(k === 'g'){
      if(!isPlaying){ e.preventDefault(); saveGif(); }
    }else if(k === 'l'){
      if(!isPlaying){ e.preventDefault(); loadProjectInput.value = ''; loadProjectInput.click(); }
    }else if(k === 'n'){
      if(!isPlaying){
        e.preventDefault();
        frames = Array.from({length: 12}, ()=>makeBlankFrame());
        undoStacks = [];
        redoStacks = [];
        ensureStacks(frames.length);
        current = 0;
        initThumbs(false);
        renderAllThumbs();
        renderMain();
        updateUI();
      }
    }else if(k === 'a'){
      if(!isPlaying){ e.preventDefault(); addBlankAfterCurrent(); }
    }else if(k === 'd'){
      if(!isPlaying){ e.preventDefault(); duplicateAfterCurrent(); }
    }
  }
});

// -------------------- Montage UI helpers --------------------

// Montage in-memory model
let montageChunks = []; // {id,name,source:{type,ref|project}, frameRange:{start,end}, derived:boolean, _project:optional}
let montagePlaying = false;
let selectedChunkIdx = -1;
let _trimDragging = null;
let currentMode = 'chunk'; // 'chunk' | 'montage' - used to gate drawing and UI state
 // 'left'|'right' or null

function generateId(prefix='chunk'){
  return `${prefix}-${Date.now().toString(36)}-${Math.floor(Math.random()*0x10000).toString(16)}`;
}

// append a small import log helper for Montage imports (visible in the Montage sidebar)
function addImportLog(msg){
  try{
    const el = document.getElementById('importLog');
    if(!el) return;
    const row = document.createElement('div');
    row.textContent = msg;
    el.appendChild(row);
    // keep last ~200 lines bounded
    while(el.children.length > 200) el.removeChild(el.firstChild);
    el.scrollTop = el.scrollHeight;
    console.debug('ImportLog:', msg);
  }catch(e){ console.error('addImportLog error', e); }
}

function computeMontageTotalFrames(){
  return montageChunks.reduce((s,ch)=> s + Math.max(0, (ch.frameRange && (ch.frameRange.end - ch.frameRange.start)) || 0), 0);
}

function updateMontageMetaUI(){
  const el = document.getElementById('montageTotalFrames');
  if(!el) return;
  el.textContent = String(computeMontageTotalFrames());
}

function updateMontageScrubberUI(){
  const total = Math.max(1, computeMontageTotalFrames());
  const scrub = montageScrubber;
  if(!scrub) return;
  scrub.step = '1';
  scrub.max = String(total);

  // choose a sensible position depending on mode/play state/selection
  let pos = 1;
  if(currentMode === 'montage'){
    if(montagePlaying){
      let before = 0;
      for(let i=0;i<Math.min(_montagePos.chunkIdx, montageChunks.length); i++){
        const c = montageChunks[i]; before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0;
      }
      pos = Math.min(before + (_montagePos.frameIdx || 0) + 1, total);
    }else if(selectedChunkIdx >= 0){
      let before = 0;
      for(let i=0;i<selectedChunkIdx;i++){ const c = montageChunks[i]; before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0; }
      pos = Math.min(before + 1, total);
    }else{
      pos = 1;
    }
  }else{
    pos = clamp(current + 1, 1, total);
  }

  scrub.value = String(pos);
  const playPosEl = document.getElementById('montagePlayPos'); if(playPosEl) playPosEl.textContent = `${pos} / ${total}f`;
}

function selectMontageChunk(idx, renderPreview = true){
  // clamp
  if(typeof idx !== 'number' || montageChunks.length === 0){ selectedChunkIdx = -1; }
  else selectedChunkIdx = clamp(idx, 0, montageChunks.length - 1);

  const container = document.getElementById('montageChunks');
  Array.from(container.children).forEach((child,i)=> child.classList.toggle('active', i === selectedChunkIdx));
  const ch = montageChunks[selectedChunkIdx];
  const trimBar = document.getElementById('trimBar');
  // show trim bar only in montage mode
  trimBar.style.display = (currentMode === 'montage') ? '' : 'none';

  const startInp = document.getElementById('trimStartInput');
  const endInp = document.getElementById('trimEndInput');
  const trimApply = document.getElementById('trimApplyBtn');
  const trimReset = document.getElementById('trimResetBtn');

  if(!ch){
    // no selection
    if(startInp) startInp.value = '';
    if(endInp) endInp.value = '';
    if(trimApply) trimApply.disabled = true;
    if(trimReset) trimReset.disabled = true;
    // clear trim bar handles
    updateTrimBar();
    // ensure canvas reflects current workspace
    if(currentMode === 'montage'){
      if(renderPreview) renderMontagePreviewChunk(-1);
      else {
        // keep canvas showing neutral blank when caller requested skipping preview render
        const blank = new Uint8Array(W*H); blank.fill(240); renderPreviewFrameBytes(blank);
      }
    } else { renderMain(); }
    return;
  }

  // set numeric inputs
  if(startInp) startInp.value = String(ch.frameRange.start);
  if(endInp) endInp.value = String(ch.frameRange.end);

  // enable apply/reset only if project data available
  const hasProject = !!ch._project;
  if(trimApply) trimApply.disabled = !hasProject;
  if(trimReset) trimReset.disabled = !hasProject;

  updateTrimBar();
  // update canvas preview when in montage mode unless caller asked to skip render
  if(currentMode === 'montage' && renderPreview){ renderMontagePreviewChunk(selectedChunkIdx); }
}

function updateTrimBar(){
  const c = document.getElementById('trimBarCanvas');
  if(!c) return;
  c.innerHTML = '';
  if(selectedChunkIdx < 0 || selectedChunkIdx >= montageChunks.length) return;
  const ch = montageChunks[selectedChunkIdx];
  if(!ch._project) return;
  const total = ch._project.frameCount || (ch._project.frames && ch._project.frames.length) || (ch.frameRange && ch.frameRange.end) || 0;
  if(total <= 0) return;

  // selection area
  const sel = document.createElement('div'); sel.className = 'trim-selection';
  const leftPercent = (ch.frameRange.start / total) * 100;
  const rightPercent = (ch.frameRange.end / total) * 100;
  sel.style.left = leftPercent + '%'; sel.style.width = (rightPercent - leftPercent) + '%';
  c.appendChild(sel);

  const leftH = document.createElement('div'); leftH.className = 'trim-handle'; leftH.style.left = `calc(${leftPercent}% - 5px)`;
  const rightH = document.createElement('div'); rightH.className = 'trim-handle'; rightH.style.left = `calc(${rightPercent}% - 5px)`;
  c.appendChild(leftH); c.appendChild(rightH);

  function toFrame(x){
    const rect = c.getBoundingClientRect(); const rel = clamp((x - rect.left) / rect.width, 0, 1); return Math.round(rel * total);
  }

  // pointer handlers for left/right handles
  leftH.addEventListener('pointerdown', (ev)=>{ ev.preventDefault(); _trimDragging = 'left'; leftH.setPointerCapture(ev.pointerId); });
  rightH.addEventListener('pointerdown', (ev)=>{ ev.preventDefault(); _trimDragging = 'right'; rightH.setPointerCapture(ev.pointerId); });

  // update visuals immediately (drag handlers use global pointer listeners)
  const leftPct = (ch.frameRange.start / total) * 100; const rightPct = (ch.frameRange.end / total) * 100;
  sel.style.left = leftPct + '%'; sel.style.width = (rightPct - leftPct) + '%'; leftH.style.left = `calc(${leftPct}% - 5px)`; rightH.style.left = `calc(${rightPct}% - 5px)`;
}

// Trim apply/reset buttons
const trimApplyBtnObs = function(){ const si = Number(document.getElementById('trimStartInput').value); const ei = Number(document.getElementById('trimEndInput').value); if(selectedChunkIdx>=0){ const ch = montageChunks[selectedChunkIdx]; ch.frameRange = {start: si, end: ei}; ch.derived = true; renderMontageChunks(); updateMontageMetaUI(); updateTrimBar(); updateMontageScrubberUI(); notify('Chunk trimmed (non-destructive).'); }};
const trimResetBtnObs = function(){ if(selectedChunkIdx>=0){ const ch = montageChunks[selectedChunkIdx]; ch.frameRange = {start:0, end: (ch._project && (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))) || ch.frameRange.end}; ch.derived = false; renderMontageChunks(); updateMontageMetaUI(); updateTrimBar(); updateMontageScrubberUI(); notify('Trim reset (restored full range).'); }};

// Global pointer handlers for draggable trim (single listeners to avoid accumulation)
function _globalTrimPointerMove(ev){ if(!_trimDragging || selectedChunkIdx < 0) return; const c = document.getElementById('trimBarCanvas'); if(!c) return; const ch = montageChunks[selectedChunkIdx]; if(!ch._project) return; const total = ch._project.frameCount || (ch._project.frames && ch._project.frames.length) || 0; if(total <= 0) return; const rect = c.getBoundingClientRect(); const rel = clamp((ev.clientX - rect.left) / rect.width, 0, 1); const f = Math.round(rel * total); if(_trimDragging === 'left'){ const newStart = clamp(Math.min(f, ch.frameRange.end - 1), 0, total - 1); ch.frameRange.start = newStart; document.getElementById('trimStartInput').value = String(ch.frameRange.start); }else if(_trimDragging === 'right'){ const newEnd = clamp(Math.max(f, ch.frameRange.start + 1), 1, total); ch.frameRange.end = newEnd; document.getElementById('trimEndInput').value = String(ch.frameRange.end); } updateTrimBar(); }
function _globalTrimPointerUp(ev){ if(!_trimDragging) return; _trimDragging = null; renderMontageChunks(); updateMontageMetaUI(); updateMontageScrubberUI(); notify('Chunk trimmed (non-destructive).'); }
window.addEventListener('pointermove', _globalTrimPointerMove);
window.addEventListener('pointerup', _globalTrimPointerUp);

// wire buttons when DOM ready (guard)
window.addEventListener('DOMContentLoaded', ()=>{
  const a = document.getElementById('trimApplyBtn'); if(a) a.addEventListener('click', trimApplyBtnObs);
  const r = document.getElementById('trimResetBtn'); if(r) r.addEventListener('click', trimResetBtnObs);

  // wire editor toggle buttons here to ensure they exist and to add safe handlers
  const tc = document.getElementById('toggleChunk'); if(tc) tc.addEventListener('click', ()=> { console.debug('toggleChunk clicked'); setMode('chunk'); });
  const tm = document.getElementById('toggleMontage'); if(tm) tm.addEventListener('click', ()=> { console.debug('toggleMontage clicked'); setMode('montage'); });

});

function setMode(mode){
  const isMontage = mode === 'montage';
  const newMode = isMontage ? 'montage' : 'chunk';
  if(currentMode === newMode){ console.debug('setMode: already', currentMode); return; }
  currentMode = newMode;
  console.debug('setMode ->', currentMode);
  notify(`Switched to ${currentMode === 'montage' ? 'Montage Editor' : 'Chunk Editor'}`);

  document.getElementById('montageSidebar').style.display = isMontage ? '' : 'none';
  // hide the frames sidebar when in montage mode
  const framesSidebar = document.querySelector('.sidebar');
  // the frames sidebar is the first .sidebar; when montage is active we still want it hidden.
  if(framesSidebar) framesSidebar.style.display = isMontage ? 'none' : '';
  document.getElementById('toggleChunk').classList.toggle('primary', !isMontage);
  document.getElementById('toggleMontage').classList.toggle('primary', isMontage);

  // trim bar should be visible only in montage mode
  const trimBar = document.getElementById('trimBar'); if(trimBar) trimBar.style.display = isMontage ? '' : 'none';

  // show appropriate play button based on mode
  if(playBtn) playBtn.style.display = isMontage ? 'none' : '';
  if(montagePlayBtn) montagePlayBtn.style.display = isMontage ? '' : 'none';

  // hide drawing panel in montage mode
  const drawingPanel = document.getElementById('drawingPanel'); if(drawingPanel) drawingPanel.style.display = isMontage ? 'none' : '';

  // disable drawing/frame-edit controls while in montage mode
  const drawingControls = [toolPencil, toolEraser, toolSoft, undoBtn, redoBtn, addFrameBtn, dupFrameBtn, delFrameBtn, brushSize, graySlider, onionSlider];
  drawingControls.forEach(el => { if(el) el.disabled = isMontage; });

  // select first chunk when entering montage mode
  if(isMontage && montageChunks.length > 0 && selectedChunkIdx === -1){ selectMontageChunk(0); }

  if(isMontage){
    // render preview for the selected chunk (or blank preview)
    renderMontagePreviewChunk(selectedChunkIdx);
    // show montage scrubber and set its range
    if(montageScrubber){ 
      montageScrubber.style.display = '';
      montageScrubber.step = '1';
      montageScrubber.max = String(Math.max(1, computeMontageTotalFrames()));
      if(selectedChunkIdx >= 0){ 
        let before = 0; for(let i=0;i<selectedChunkIdx;i++){ const c = montageChunks[i]; before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0; }
        montageScrubber.value = String(before + 1);
      }
    }
    main.style.cursor = 'default';
  }else{
    // restore chunk editor view and cursor
    renderMain();
    if(montageScrubber) {
      montageScrubber.style.display = '';
      montageScrubber.step = '1';
      montageScrubber.max = String(frames.length);
      montageScrubber.value = String(current + 1);
    }
    main.style.cursor = 'crosshair';
  }
} 

function addMontageChunk(obj){
  montageChunks.push(obj);
  renderMontageChunks();
  updateMontageMetaUI();
  updateMontageScrubberUI();
  // select first chunk by default when first chunk added
  if(montageChunks.length === 1){ selectMontageChunk(0); }
}

function renderMontageChunks(){
  const container = document.getElementById('montageChunks');
  container.innerHTML = '';
  montageChunks.forEach((ch, idx)=>{
    const div = document.createElement('div');
    div.className = 'chunk-item';

    // show per-chunk duration badge
    const durationBadge = document.createElement('span'); durationBadge.className = 'pill'; durationBadge.style.marginRight = '8px'; durationBadge.textContent = `${(ch.frameRange.end - ch.frameRange.start)}f`;
    div.appendChild(durationBadge);

    // show embedded/reference badge
    const sourceBadge = document.createElement('span'); sourceBadge.className = 'pill'; sourceBadge.style.marginRight = '8px'; sourceBadge.textContent = ch.source && ch.source.type === 'embedded' ? 'embedded' : 'ref';
    div.appendChild(sourceBadge);

    const left = document.createElement('div');
    left.style.display = 'flex'; left.style.gap = '10px'; left.style.alignItems = 'center';
    const title = document.createElement('div');
    title.style.display = 'flex'; title.style.flexDirection = 'column';
    const nameEl = document.createElement('div'); nameEl.innerHTML = `<strong>${ch.name}</strong>`;
    const metaEl = document.createElement('div'); metaEl.className = 'chunk-meta';
    const startInput = document.createElement('input'); startInput.type = 'number'; startInput.value = String(ch.frameRange.start); startInput.min = 0; startInput.style.width = '62px'; startInput.className = 'trim-start-input';
    const endInput = document.createElement('input'); endInput.type = 'number'; endInput.value = String(ch.frameRange.end); endInput.min = (Number(ch.frameRange.start) + 1) ; endInput.style.width = '62px'; endInput.className = 'trim-end-input';
    const refInput = document.createElement('input'); refInput.type = 'text'; refInput.value = (ch.source && ch.source.ref) ? ch.source.ref : ''; refInput.style.width = '160px'; refInput.className = 'ref-input';
    const setCanonBtn = document.createElement('button'); setCanonBtn.textContent = `Use example/${ch.name}.json`;
    metaEl.appendChild(document.createTextNode('frames: ')); metaEl.appendChild(startInput); metaEl.appendChild(document.createTextNode(' .. ')); metaEl.appendChild(endInput);
    metaEl.appendChild(document.createTextNode(` (${ch.frameRange.end - ch.frameRange.start}f)`));
    metaEl.appendChild(document.createElement('br'));
    const refLabel = document.createElement('small'); refLabel.style.color = 'var(--muted)'; refLabel.textContent = 'ref: ';
    metaEl.appendChild(refLabel); metaEl.appendChild(refInput); metaEl.appendChild(setCanonBtn);
    title.appendChild(nameEl); title.appendChild(metaEl);

    // events: select on click
    div.addEventListener('click', ()=>{ selectMontageChunk(idx); });

    // trim inputs
    startInput.addEventListener('change', ()=>{
      const tot = (ch._project && (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))) || ch.frameRange.end;
      let si = clamp(Number(startInput.value), 0, tot-1);
      let ei = clamp(Number(endInput.value), si+1, tot);
      ch.frameRange = {start: si, end: ei}; ch.derived = true; renderMontageChunks(); updateMontageMetaUI(); updateTrimBar(); updateMontageScrubberUI(); notify('Chunk trimmed (non-destructive).');
    });
    endInput.addEventListener('change', ()=>{
      const tot = (ch._project && (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))) || ch.frameRange.end;
      let si = clamp(Number(startInput.value), 0, tot-1);
      let ei = clamp(Number(endInput.value), si+1, tot);
      ch.frameRange = {start: si, end: ei}; ch.derived = true; renderMontageChunks(); updateMontageMetaUI(); updateTrimBar(); updateMontageScrubberUI(); notify('Chunk trimmed (non-destructive).');
    });

    refInput.addEventListener('change', ()=>{ if(!ch.source) ch.source = {type:'reference', ref: refInput.value}; else ch.source.ref = refInput.value; notify('Reference updated.'); });
    setCanonBtn.addEventListener('click', ()=>{ refInput.value = `example/${ch.name}.json`; refInput.dispatchEvent(new Event('change')); });

    const controls = document.createElement('div');
    controls.className = 'chunk-controls';

    // Note: per-chunk Trim button removed in favor of inline inputs + trim bar


    const saveTrimBtn = document.createElement('button'); saveTrimBtn.textContent = 'Save trimmed';
    saveTrimBtn.addEventListener('click', ()=>{
      if(!ch._project){ notify('Source project not loaded in-memory. Cannot save trimmed chunk.'); return; }
      const start = ch.frameRange.start; const end = ch.frameRange.end;
      const project = ch._project;
      const newFrames = project.frames.slice(start, end);
      const out = {
        version: project.version || '1.x',
        width: project.width, height: project.height, fps: project.fps,
        frameCount: newFrames.length, timestamp: new Date().toISOString(), frames: newFrames
      };
      const blob = new Blob([JSON.stringify(out, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = `${ch.name || ch.id}-trimmed.json`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      notify('Saved trimmed chunk as new project JSON.');
    });

    const upBtn = document.createElement('button'); upBtn.className = 'iconBtn'; upBtn.title = 'Move Up'; upBtn.textContent = '▴';
    upBtn.addEventListener('click', ()=>{ if(idx === 0) return; [montageChunks[idx-1], montageChunks[idx]] = [montageChunks[idx], montageChunks[idx-1]]; renderMontageChunks(); updateMontageMetaUI(); updateMontageScrubberUI(); });

    const downBtn = document.createElement('button'); downBtn.className = 'iconBtn'; downBtn.title = 'Move Down'; downBtn.textContent = '▾';
    downBtn.addEventListener('click', ()=>{ if(idx === montageChunks.length-1) return; [montageChunks[idx+1], montageChunks[idx]] = [montageChunks[idx], montageChunks[idx+1]]; renderMontageChunks(); updateMontageMetaUI(); updateMontageScrubberUI(); });

    const delBtn = document.createElement('button'); delBtn.className = 'iconBtn danger'; delBtn.title = 'Delete'; delBtn.textContent = '✖';
    delBtn.addEventListener('click', ()=>{ montageChunks.splice(idx,1); renderMontageChunks(); updateMontageMetaUI(); updateMontageScrubberUI(); });

    // per-chunk trim button intentionally removed in favor of inline inputs + trim bar
    controls.appendChild(saveTrimBtn);
    controls.appendChild(upBtn);
    controls.appendChild(downBtn);
    controls.appendChild(delBtn);

    left.appendChild(title);
    div.appendChild(left);
    div.appendChild(controls);

    div.addEventListener('dblclick', ()=>{ // on dblclick select and focus start input
      selectMontageChunk(idx);
      const si = div.querySelector('.trim-start-input'); if(si) si.focus();
    });

    container.appendChild(div);
  });
}

// Wire up UI controls for Montage
const toggleChunkBtn = document.getElementById('toggleChunk');
const toggleMontageBtn = document.getElementById('toggleMontage');
const montageImportBtn = document.getElementById('montageImportBtn');
const montageImportInputEl = document.getElementById('montageImportInput');
const montageEmbedCheckbox = document.getElementById('montageEmbedCheckbox');
const saveMontageBtn = document.getElementById('saveMontageBtn');
const montagePlayBtn = document.getElementById('montagePlayBtn');

// Default mode is chunk editor
setMode('chunk');

// toggle event handlers are wired on DOMContentLoaded to ensure elements exist
montageImportBtn.addEventListener('click', ()=> montageImportInputEl.click());

montageImportInputEl.addEventListener('change', (ev)=>{
  const files = Array.from(ev.target.files || []);
  if(files.length === 0) return;
  files.forEach(f => {
    const fr = new FileReader();
    fr.onload = async ()=>{
      try{
        let json;
        try{ json = JSON.parse(String(fr.result)); }catch(err){ throw new Error(`Failed to parse ${f.name}: ${err.message}`); }

        // basic validation: width/height/fps match current project
        if(json.width !== W || json.height !== H || json.fps !== FPS){
          throw new Error(`Skipped ${f.name}: width/height/fps mismatch (got ${json.width}x${json.height}@${json.fps})`);
        }

        // use shared validation helper for consistent checks
        if(typeof validateProject !== 'function') throw new Error('Validation function not available');
        const vres = validateProject(json, { width: W, height: H, fps: FPS });
        if(!vres.ok) throw new Error(`${f.name} failed validation: ${vres.errors.join('; ')}`);

        let refVal = f.name;
        // try to set canonical example/ path if accessible (only when served over http(s))
        try{
          if(location && location.protocol && (location.protocol === 'http:' || location.protocol === 'https:')){
            const resp = await fetch(`example/${f.name}`);
            if(resp.ok) refVal = `example/${f.name}`;
          }
        }catch(_){ /* ignore */ }

        const ch = {
          id: generateId('chunk'),
          name: f.name.replace(/\.json$/i, ''),
          source: montageEmbedCheckbox.checked ? {type:'embedded', project: json} : {type:'reference', ref: refVal},
          frameRange: {start:0, end: (json.frameCount || (json.frames && json.frames.length) || 0)},
          derived: false,
          _project: json
        };
        addMontageChunk(ch);
        // if no selection yet, select this chunk
        if(selectedChunkIdx === -1) selectMontageChunk(0);
        notify(`Imported ${f.name}`);
        addImportLog(`${f.name}: Imported`);
      }catch(err){
        notify(err.message || String(err));
        console.error('Import error:', f.name, err);
        addImportLog(`${f.name}: Error - ${err.message || String(err)}`);
      }
    };
    fr.onerror = (e)=>{ notify(`Failed to read ${f.name}`); console.error('FileReader error', f.name, e); addImportLog(`${f.name}: Read error`); };
    fr.readAsText(f);
  });
  // clear input so same file can be reselected
  montageImportInputEl.value = '';
});

saveMontageBtn.addEventListener('click', ()=>{
  const out = {
    version: 'montage-1.0', width: W, height: H, fps: FPS, timestamp: new Date().toISOString(), chunks: []
  };
  montageChunks.forEach(ch => {
    const item = { id: ch.id, name: ch.name, frameRange: ch.frameRange, derived: !!ch.derived };
    if(ch.source && ch.source.type === 'embedded') item.source = { type: 'embedded', project: ch.source.project };
    else if(ch.source && ch.source.type === 'reference') item.source = { type: 'reference', ref: ch.source.ref };
    out.chunks.push(item);
  });
  const blob = new Blob([JSON.stringify(out, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `montage-${new Date().toISOString().replace(/[:.]/g,'-')}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  notify('Montage saved.');
});

let _montageTimer = null;
let _montagePos = { chunkIdx: 0, frameIdx: 0 };

function renderPreviewFrameBytes(bytes){
  // bytes: Uint8Array of length W*H
  const out = new Uint8ClampedArray(W*H*4);
  for(let p=0,o=0; p<bytes.length; p++,o+=4){ const v = bytes[p]; out[o]=v; out[o+1]=v; out[o+2]=v; out[o+3]=255; }
  const id = new ImageData(out, W, H);
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const target = DISPLAY * dpr;
  if(main.width !== target || main.height !== target){ main.width = target; main.height = target; }
  offCtx.putImageData(id, 0, 0);
  ctx.clearRect(0,0, main.width, main.height);
  ctx.drawImage(off, 0, 0, main.width, main.height);
}

function _decodeFrameFromProject(project, idx){
  const base64 = project.frames[idx];
  const binary = atob(base64);
  const arr = new Uint8Array(binary.length);
  for(let j=0;j<binary.length;j++) arr[j] = binary.charCodeAt(j);
  return arr;
}

// Render a read-only preview for a montage chunk into the main canvas
function renderMontagePreviewChunk(idx){
  const ch = montageChunks[idx];
  if(!ch){
    // no selection: show editor view when in chunk mode, otherwise clear preview
    if(currentMode === 'chunk'){ renderMain(); return; }
    const blank = new Uint8Array(W*H); blank.fill(240); renderPreviewFrameBytes(blank); return;
  }

  if(ch._project && Array.isArray(ch._project.frames) && ch.frameRange && ch.frameRange.start < ch._project.frames.length){
    try{
      const bytes = _decodeFrameFromProject(ch._project, ch.frameRange.start);
      renderPreviewFrameBytes(bytes);
      // overlay chunk name so user knows what they're previewing
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.font = '14px sans-serif';
      ctx.fillText(ch.name || '', 8, 18);
      ctx.restore();
      return;
    }catch(e){ console.error('Preview render failed', e); }
  }

  // fallback: neutral blank with message
  const blank = new Uint8Array(W*H); blank.fill(240); renderPreviewFrameBytes(blank);
  ctx.save();
  ctx.fillStyle = 'rgba(180,180,180,0.9)';
  ctx.font = '14px sans-serif';
  ctx.fillText(ch.name ? `${ch.name} (no project loaded)` : 'No preview', 8, 18);
  ctx.restore();
}

function startMontagePlayback(){
  if(montageChunks.length === 0) { notify('No chunks to play'); return; }
  // start at first chunk/frame
  _montagePos = { chunkIdx: 0, frameIdx: 0 };
  montagePlaying = true; montagePlayBtn.textContent = 'Stop';

  // init playback UI
  const playPosEl = document.getElementById('montagePlayPos');
  if(playPosEl) playPosEl.textContent = `0 / ${computeMontageTotalFrames()}f`;

  // remember last highlighted chunk so we only update selection on chunk change (avoids overwriting the current preview)
  let lastChunkIdx = -1;

  _montageTimer = setInterval(()=>{
    // out-of-range -> stop
    if(_montagePos.chunkIdx >= montageChunks.length){ stopMontagePlayback(); return; }
    const ch = montageChunks[_montagePos.chunkIdx];
    const total = (ch.frameRange && (ch.frameRange.end - ch.frameRange.start)) || 0;
    if(total <= 0){ _montagePos.chunkIdx++; _montagePos.frameIdx = 0; return; }

    // ensure project loaded
    if(!ch._project){ notify('Project data not loaded for chunk: ' + ch.name); stopMontagePlayback(); return; }
    const frameInSource = ch.frameRange.start + _montagePos.frameIdx;
    if(frameInSource >= (ch._project.frameCount || (ch._project.frames && ch._project.frames.length))) { _montagePos.chunkIdx++; _montagePos.frameIdx = 0; return; }

    // render the actual frame in the chunk (do not let selection preview overwrite it every tick)
    const bytes = _decodeFrameFromProject(ch._project, frameInSource);
    renderPreviewFrameBytes(bytes);

    // only update the selected chunk when we actually moved to a new chunk
    if(lastChunkIdx !== _montagePos.chunkIdx){
      // update selection highlight but do not force a chunk-start preview render
      selectMontageChunk(_montagePos.chunkIdx, false);
      lastChunkIdx = _montagePos.chunkIdx;
    }

      // update playback position UI (global frame index)
    const totalMontage = computeMontageTotalFrames();
    let before = 0;
    for(let i=0;i<_montagePos.chunkIdx;i++){
      const c = montageChunks[i];
      before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0;
    }
    const pos = before + _montagePos.frameIdx + 1;
    if(playPosEl) playPosEl.textContent = `${pos} / ${totalMontage}f`;
    // sync montageScrubber if present
    if(montageScrubber && currentMode === 'montage'){
      montageScrubber.max = String(totalMontage);
      montageScrubber.value = String(pos);
    }

    // update montage scrubber so progress moves during montage playback
    if(montageScrubber && currentMode === 'montage'){
      montageScrubber.max = String(totalMontage);
      montageScrubber.value = String(pos);
    }

    // advance
    _montagePos.frameIdx++;
    if(_montagePos.frameIdx >= total){ _montagePos.chunkIdx++; _montagePos.frameIdx = 0; }
    updateMontageMetaUI();
  }, Math.round(1000 / FPS));
}

function stopMontagePlayback(){
  montagePlaying = false; montagePlayBtn.textContent = 'Play';
  if(_montageTimer){ clearInterval(_montageTimer); _montageTimer = null; }
  // select the chunk where playback stopped
  const idx = Math.min(_montagePos.chunkIdx, montageChunks.length - 1);
  if(idx >= 0 && montageChunks.length > 0) selectMontageChunk(idx);
  const playPosEl = document.getElementById('montagePlayPos'); if(playPosEl) playPosEl.textContent = `0 / ${computeMontageTotalFrames()}f`;
  // sync montage scrubber to current position and visibility
  if(currentMode === 'montage'){
    const totalMontage = Math.max(1, computeMontageTotalFrames());
    if(montageScrubber){
      montageScrubber.step = '1';
      montageScrubber.max = String(totalMontage);
      let before = 0; for(let i=0;i<Math.min(_montagePos.chunkIdx, montageChunks.length);i++){ const c = montageChunks[i]; before += (c.frameRange && (c.frameRange.end - c.frameRange.start)) || 0; }
      montageScrubber.value = String(Math.min(before + (_montagePos.frameIdx || 0) + 1, totalMontage));
      montageScrubber.style.display = '';
    }
  }else{
    if(montageScrubber) montageScrubber.style.display = 'none';
  }
  notify('Montage stopped');
}

montagePlayBtn.addEventListener('click', ()=>{
  if(montagePlaying) stopMontagePlayback(); else startMontagePlayback();
});

// -------------------- Init --------------------
// Initializes a default 12-frame blank project. Modify this to change default
// startup state (e.g., load a sample file or change initial frame count).

function init(){
  frames = Array.from({length: 12}, ()=>makeBlankFrame());
  ensureStacks(frames.length);

  setTool('pencil');
  brushSizeLabel.textContent = brushSize.value;
  grayLabel.textContent = graySlider.value;
  onionLabel.textContent = onionSlider.value;

  initThumbs(false);
  renderMain();
  updateUI();

  // initial montage UI state
  selectMontageChunk(-1);

  // set initial button visibility (chunk mode by default)
  if(playBtn) playBtn.style.display = '';
  if(montagePlayBtn) montagePlayBtn.style.display = 'none';

  window.addEventListener('resize', ()=>renderMain());
}

init();

})();
</script>
</body>
</html>
